{"version":3,"sources":["ng://ngrx-data/actions/entity-action-factory.ts","ng://ngrx-data/actions/entity-action-guard.ts","ng://ngrx-data/utils/utilities.ts","ng://ngrx-data/actions/entity-action-operators.ts","ng://ngrx-data/actions/entity-cache-change-set.ts","ng://ngrx-data/actions/merge-strategy.ts","ng://ngrx-data/actions/entity-cache-action.ts","ng://ngrx-data/actions/entity-op.ts","ng://ngrx-data/dataservices/data-service-error.ts","ng://ngrx-data/dataservices/default-data-service-config.ts","ng://ngrx-data/utils/interfaces.ts","ng://ngrx-data/dataservices/http-url-generator.ts","ng://ngrx-data/dataservices/default-data.service.ts","ng://ngrx-data/entity-metadata/entity-definition.ts","ng://ngrx-data/entity-metadata/entity-metadata.ts","ng://ngrx-data/entity-metadata/entity-definition.service.ts","ng://ngrx-data/dataservices/entity-cache-data.service.ts","ng://ngrx-data/dataservices/entity-data.service.ts","ng://ngrx-data/dataservices/persistence-result-handler.service.ts","ng://ngrx-data/utils/correlation-id-generator.ts","ng://ngrx-data/dispatchers/entity-dispatcher-default-options.ts","ng://ngrx-data/dispatchers/entity-dispatcher.ts","ng://ngrx-data/dispatchers/entity-cache-dispatcher.ts","ng://ngrx-data/dispatchers/entity-dispatcher-base.ts","ng://ngrx-data/reducers/constants.ts","ng://ngrx-data/selectors/entity-cache-selector.ts","ng://ngrx-data/dispatchers/entity-dispatcher-factory.ts","ng://ngrx-data/effects/entity-effects-scheduler.ts","ng://ngrx-data/effects/entity-cache-effects.ts","ng://ngrx-data/effects/entity-effects.ts","ng://ngrx-data/entity-services/entity-collection-service-base.ts","ng://ngrx-data/reducers/entity-collection-creator.ts","ng://ngrx-data/selectors/entity-selectors.ts","ng://ngrx-data/selectors/entity-selectors$.ts","ng://ngrx-data/entity-services/entity-collection-service-elements-factory.ts","ng://ngrx-data/entity-services/entity-collection-service-factory.ts","ng://ngrx-data/entity-services/entity-services-elements.ts","ng://ngrx-data/entity-services/entity-services-base.ts","ng://ngrx-data/entity-services/entity-services.ts","ng://ngrx-data/reducers/entity-collection.ts","ng://ngrx-data/reducers/entity-change-tracker-base.ts","ng://ngrx-data/reducers/entity-collection-reducer-methods.ts","ng://ngrx-data/reducers/entity-collection-reducer.ts","ng://ngrx-data/reducers/entity-collection-reducer-registry.ts","ng://ngrx-data/reducers/entity-cache-reducer.ts","ng://ngrx-data/utils/default-logger.ts","ng://ngrx-data/utils/default-pluralizer.ts","ng://ngrx-data/utils/guid-fns.ts","ng://ngrx-data/utils/ngrx-entity-models.ts","ng://ngrx-data/ngrx-data-without-effects.module.ts","ng://ngrx-data/ngrx-data.module.ts","ng://ngrx-data/entity-metadata/entity-filters.ts"],"names":["EntityActionFactory","prototype","create","nameOrPayload","entityOp","data","options","payload","tslib_1","__assign","entityName","this","createCore","tag","Error","type","formatActionType","createFromAction","from","newProperties","op","Injectable","EntityActionGuard","selectId","mustBeEntity","action","extractData","throwError","id","isNotKeyType","mustBeEntities","_this","Array","isArray","forEach","entity","i","msg","mustBeKey","mustBeKeys","mustBeUpdate","changes","id2","mustBeUpdates","item","mustBeUpdateResponse","mustBeUpdateResponses","defaultSelectId","undefined","flattenArgs","args","_a","__read","head","tail","slice","__spread","toUpdateFactory","ofEntityOp","allowedEntityOps","_i","arguments","length","ops","filter","op_1","some","o","ofEntityType","allowedEntityNames","names","name_1","n","Add","Delete","Update","Upsert","ChangeSetItemFactory","add","entities","ChangeSetOperation","delete","keys","ids","update","updates","upsert","changeSetItemFactory","excludeEmptyChangeSetItems","changeSet","c","IgnoreChanges","PreserveChanges","OverwriteChanges","CLEAR_COLLECTIONS","LOAD_COLLECTIONS","MERGE_QUERY_SET","SET_ENTITY_CACHE","SAVE_ENTITIES","SAVE_ENTITIES_CANCEL","SAVE_ENTITIES_CANCELED","SAVE_ENTITIES_ERROR","SAVE_ENTITIES_SUCCESS","ClearCollections","collections","EntityCacheAction","LoadCollections","MergeQuerySet","querySet","mergeStrategy","MergeStrategy","SetEntityCache","cache","SaveEntities","url","SaveEntitiesCancel","correlationId","reason","entityNames","SaveEntitiesCanceled","SaveEntitiesError","error","originalAction","SaveEntitiesSuccess","CANCEL_PERSIST","CANCELED_PERSIST","QUERY_ALL","QUERY_ALL_SUCCESS","QUERY_ALL_ERROR","QUERY_LOAD","QUERY_LOAD_SUCCESS","QUERY_LOAD_ERROR","QUERY_MANY","QUERY_MANY_SUCCESS","QUERY_MANY_ERROR","QUERY_BY_KEY","QUERY_BY_KEY_SUCCESS","QUERY_BY_KEY_ERROR","SAVE_ADD_MANY","SAVE_ADD_MANY_ERROR","SAVE_ADD_MANY_SUCCESS","SAVE_ADD_ONE","SAVE_ADD_ONE_ERROR","SAVE_ADD_ONE_SUCCESS","SAVE_DELETE_MANY","SAVE_DELETE_MANY_SUCCESS","SAVE_DELETE_MANY_ERROR","SAVE_DELETE_ONE","SAVE_DELETE_ONE_SUCCESS","SAVE_DELETE_ONE_ERROR","SAVE_UPDATE_MANY","SAVE_UPDATE_MANY_SUCCESS","SAVE_UPDATE_MANY_ERROR","SAVE_UPDATE_ONE","SAVE_UPDATE_ONE_SUCCESS","SAVE_UPDATE_ONE_ERROR","SAVE_UPSERT_MANY","SAVE_UPSERT_MANY_SUCCESS","SAVE_UPSERT_MANY_ERROR","SAVE_UPSERT_ONE","SAVE_UPSERT_ONE_SUCCESS","SAVE_UPSERT_ONE_ERROR","ADD_ALL","ADD_MANY","ADD_ONE","REMOVE_ALL","REMOVE_MANY","REMOVE_ONE","UPDATE_MANY","UPDATE_ONE","UPSERT_MANY","UPSERT_ONE","COMMIT_ALL","COMMIT_MANY","COMMIT_ONE","UNDO_ALL","UNDO_MANY","UNDO_ONE","SET_CHANGE_STATE","SET_COLLECTION","SET_FILTER","SET_LOADED","SET_LOADING","OP_SUCCESS","OP_ERROR","makeErrorOp","makeSuccessOp","DataServiceError","requestData","sourceError","errMessage","body","message","JSON","stringify","DefaultDataServiceConfig","Logger","PLURAL_NAMES_TOKEN","InjectionToken","Pluralizer","EntityHttpResourceUrls","HttpUrlGenerator","DefaultHttpUrlGenerator","pluralizer","getResourceUrls","root","resourceUrls","knownHttpResourceUrls","nRoot","normalizeRoot","entityResourceUrl","toLowerCase","collectionResourceUrl","pluralize","registerHttpResourceUrls","entityResource","collectionResource","entityHttpResourceUrls","replace","DefaultDataService","http","httpUrlGenerator","config","_name","_b","_c","delete404OK","_d","getDelay","_e","saveDelay","_f","timeout","to","entityUrl","entitiesUrl","Object","defineProperty","entityOrError","execute","key","err","pipe","map","result","getAll","getById","getWithQuery","queryParams","qParams","fromString","fromObject","params","HttpParams","updateOrError","method","result$","req","handleError","delay","get","post","put","catchError","reqData","ok","handleDelete404","status","of","DefaultDataServiceFactory","HttpClient","decorators","Optional","createEntityDefinition","metadata","trim","sortComparer","entityAdapter","createEntityAdapter","entityDispatcherOptions","initialState","getInitialState","loaded","loading","changeState","additionalCollectionState","noChangeTracking","ENTITY_METADATA_TOKEN","EntityDefinitionService","entityMetadataMaps","registerMetadataMap","getDefinition","shouldThrow","definition","definitions","registerMetadata","registerDefinition","metadataMap","registerDefinitions","assign","Inject","updateOp","EntityCacheDataService","entityDefinitionService","saveEntities","filterChangeSet","flattenUpdates","restoreUpdates","hasMutated","u","selectId_1","getIdSelector","tslib_1.__assign","idSelector","idSelectors","EntityDataService","defaultDataServiceFactory","getService","service","services","registerService","registerServices","PersistenceResultHandler","DefaultPersistenceResultHandler","logger","entityActionFactory","handleSuccess","successOp","errorOp","errorData","CorrelationIdGenerator","next","seed","prefix","PersistanceCanceled","EntityCacheDispatcher","correlationIdGenerator","defaultDispatcherOptions","scannedActions$","store","reducedActions$","shareReplay","raSubscription","subscribe","dispatch","cancelSaveEntities","clearCollections","loadCollections","mergeQuerySet","setEntityCache","isOptimistic","optimisticSaveEntities","getSaveEntitiesResponseData$","crid","act","take","mergeMap","EntityDispatcherDefaultOptions","Observable","ScannedActionsSubject","Store","EntityDispatcherBase","entityCacheSelector","guard","toUpdate","collectionSelector","createSelector","entityCollection$","select","createEntityAction","createAndDispatch","setSaveEntityActionOptions","optimisticAdd","EntityOp","getResponseData$","withLatestFrom","e","cancel","arg","optimisticDelete","getKey","setQueryEntityActionOptions","collection","reduce","acc","push","getByKey","load","optimisticUpdate","updateData","optimisticUpsert","addAllToCache","addOneToCache","addManyToCache","clearCache","removeOneFromCache","removeManyFromCache","updateOneInCache","updateManyInCache","upsertOneInCache","upsertManyInCache","setFilter","pattern","setLoaded","isLoaded","setLoading","isLoading","endsWith","defaultOptimism","ENTITY_CACHE_NAME","ENTITY_CACHE_NAME_TOKEN","ENTITY_CACHE_META_REDUCERS","ENTITY_COLLECTION_META_REDUCERS","INITIAL_ENTITY_CACHE_STATE","ENTITY_CACHE_SELECTOR_TOKEN","entityCacheSelectorProvider","provide","useFactory","createEntityCacheSelector","deps","entityCacheName","createFeatureSelector","EntityDispatcherFactory","entityDispatcherDefaultOptions","defaultOptions","ngOnDestroy","unsubscribe","ENTITY_EFFECTS_SCHEDULER","EntityCacheEffects","actions","dataService","scheduler","ofType","a","handleSaveEntitiesError$","correlationId_1","saveEntitiesCancel$","d","concatMap","handleSaveEntitiesSuccess$","race","responseDelay","asyncScheduler","indexOf","concat","merge","name","Actions","Effect","persistOps","EntityEffects","resultHandler","persist","skip","handleSkipSuccess$","handleError$","cancel$","callDataService","id_1","changes_1","updatedEntity","changed","upsertedEntity","successAction","EntityCollectionServiceBase","serviceElementsFactory","dispatcher","selectors","selectors$","collection$","count$","entities$","entityActions$","entityMap$","errors$","filter$","filteredEntities$","keys$","loaded$","loading$","changeState$","EntityCollectionCreator","def","createEmptyEntityCollection","EntitySelectorsFactory","entityCollectionCreator","selectEntityCache","createCollectionSelector","createCollectionSelectors","metadataOrName","selectKeys","selectEntityMap","selectEntities","selectCount","selectFilter","filterFn","selectFilteredEntities","extra","extraSelectors","k","toUpperCase","selectLoaded","selectLoading","selectChangeState","selectCollection","collectionSelectors","entitySelectors","EntitySelectors$Factory","entityCache$","entityActionErrors$","ea","startsWith","name$","substr","EntityCollectionServiceElementsFactory","entityDispatcherFactory","entitySelectorsFactory","entitySelectors$Factory","EntityCollectionServiceFactory","entityCollectionServiceElementsFactory","EntityServicesElements","entityCollectionServiceFactory","EntityServicesBase","entityServicesElements","createEntityCollectionService","getEntityCollectionService","EntityCollectionServices","registerEntityCollectionService","serviceName","registerEntityCollectionServices","entityCollectionServices","EntityServices","Unchanged","Added","Deleted","Updated","EntityChangeTrackerBase","adapter","commitAll","commitMany","entityOrIdList","didMutate","chgState","entityOrId","commitOne","mergeQueryResults","mergeServerUpserts","mergeSaveAdds","mergeSaveDeletes","deleteIds","removeMany","mergeSaveUpdates","updateResponseData","skipUnchanged","filterChanged","updateMany","oldId","updateableEntities_1","newId","oldChangeState","newOrigValue","originalValue","responseData","r","mergeSaveUpserts","defaultMergeStrategy","upsertMany","upsertEntities_1","trackAddMany","changeType","ChangeType","trackAddOne","trackDeleteMany","entityMap","trackedChange","cloneChgStateOnce","trackDeleteOne","trackUpdateMany","trackUpdateOne","trackUpsertMany","trackUpsertOne","undoAll","remove","undoMany","undoOne","EntityCollectionReducerMethods","entityChangeTracker","cancelPersist","bind","queryAll","queryAllError","queryAllSuccess","queryByKey","queryByKeyError","queryByKeySuccess","queryLoad","queryLoadError","queryLoadSuccess","queryMany","queryManyError","queryManySuccess","saveAddMany","saveAddManyError","saveAddManySuccess","saveAddOne","saveAddOneError","saveAddOneSuccess","saveDeleteMany","saveDeleteManyError","saveDeleteManySuccess","saveDeleteOne","saveDeleteOneError","saveDeleteOneSuccess","saveUpdateMany","saveUpdateManyError","saveUpdateManySuccess","saveUpdateOne","saveUpdateOneError","saveUpdateOneSuccess","saveUpsertMany","saveUpsertManyError","saveUpsertManySuccess","saveUpsertOne","saveUpsertOneError","saveUpsertOneSuccess","addAll","addMany","addOne","removeAll","removeOne","updateOne","upsertOne","setChangeState","setCollection","isChangeTracking","setLoadingFalse","setLoadingTrue","extractMergeStrategy","toDelete","deleteId","change","newCollection","setLoadingFlag","EntityCollectionReducerMethodsFactory","methods","EntityCollectionReducerFactory","methodsFactory","reducerMethod","EntityCollectionReducerRegistry","entityCollectionReducerFactory","entityCollectionMetaReducers","entityCollectionMetaReducer","compose","apply","getOrCreateReducer","reducer","entityCollectionReducers","registerReducer","registerReducers","reducers","EntityCacheReducerFactory","entityCollectionReducerRegistry","entityCache","clearCollectionsReducer","loadCollectionsReducer","mergeQuerySetReducer","saveEntitiesReducer","saveEntitiesCancelReducer","saveEntitiesErrorReducer","saveEntitiesSuccessReducer","applyCollectionReducer","newCache","getEntityOp","clearLoadingFlags","isMutated","DefaultLogger","console","log","warn","uncountable","DefaultPluralizer","pluralNames","pn","registerPluralNames","plural","test","getUuid","Math","random","toString","Dictionary","ɵ0","NgrxDataModuleWithoutEffects","reducerManager","entityCacheReducerFactory","injector","metaReducers","mr","entityCacheFeature","reducerFactory","combineReducers","addFeature","forRoot","ngModule","providers","useValue","entityCacheMetaReducers","multi","removeFeature","NgModule","imports","StoreModule","useClass","ReducerManager","Injector","NgrxDataModule","effectSources","entityCacheEffects","entityEffects","addEffects","entityMetadata","effectSourceInstance","EffectsModule","EffectSources","props","regExp","RegExp","prop","timePart","Date","getTime","l","l_low","r_low"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\n\nimport { EntityOp } from './entity-op';\nimport { EntityAction, EntityActionOptions, EntityActionPayload } from './entity-action';\n@Injectable()\nexport class EntityActionFactory {\n  /**\n   * Create an EntityAction to perform an operation (op) for a particular entity type\n   * (entityName) with optional data and other optional flags\n   * @param entityName Name of the entity type\n   * @param entityOp Operation to perform (EntityOp)\n   * @param [data] data for the operation\n   * @param [options] additional options\n   */\n  create<P = any>(entityName: string, entityOp: EntityOp, data?: P, options?: EntityActionOptions): EntityAction<P>;\n\n  /**\n   * Create an EntityAction to perform an operation (op) for a particular entity type\n   * (entityName) with optional data and other optional flags\n   * @param payload Defines the EntityAction and its options\n   */\n  create<P = any>(payload: EntityActionPayload<P>): EntityAction<P>;\n\n  // polymorphic create for the two signatures\n  create<P = any>(\n    nameOrPayload: EntityActionPayload<P> | string,\n    entityOp?: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P> {\n    const payload: EntityActionPayload<P> =\n      typeof nameOrPayload === 'string' ? { ...(options || {}), entityName: nameOrPayload, entityOp, data } : nameOrPayload;\n    return this.createCore(payload);\n  }\n\n  /**\n   * Create an EntityAction to perform an operation (op) for a particular entity type\n   * (entityName) with optional data and other optional flags\n   * @param payload Defines the EntityAction and its options\n   */\n  protected createCore<P = any>(payload: EntityActionPayload<P>) {\n    const { entityName, entityOp, tag } = payload;\n    if (!entityName) {\n      throw new Error('Missing entity name for new action');\n    }\n    if (entityOp == null) {\n      throw new Error('Missing EntityOp for new action');\n    }\n    const type = this.formatActionType(entityOp, tag || entityName);\n    return { type, payload };\n  }\n\n  /**\n   * Create an EntityAction from another EntityAction, replacing properties with those from newPayload;\n   * @param from Source action that is the base for the new action\n   * @param newProperties New EntityAction properties that replace the source action properties\n   */\n  createFromAction<P = any>(from: EntityAction, newProperties: Partial<EntityActionPayload<P>>): EntityAction<P> {\n    return this.create({ ...from.payload, ...newProperties });\n  }\n\n  formatActionType(op: string, tag: string) {\n    return `[${tag}] ${op}`;\n    // return `${op} [${tag}]`.toUpperCase(); // example of an alternative\n  }\n}\n","import { EntityAction } from './entity-action';\nimport { IdSelector, Update } from '../utils/ngrx-entity-models';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\n/**\n * Guard methods that ensure EntityAction payload is as expected.\n * Each method returns that payload if it passes the guard or\n * throws an error.\n */\nexport class EntityActionGuard {\n  constructor(private entityName: string, private selectId: IdSelector<any>) {}\n\n  /** Throw if the action payload is not an entity with a valid key */\n  mustBeEntity<T = any>(action: EntityAction<T>): T {\n    const data = this.extractData(action);\n    if (!data) {\n      this.throwError(action, `should have a single entity.`);\n    }\n    const id = this.selectId(data);\n    if (this.isNotKeyType(id)) {\n      this.throwError(action, `has a missing or invalid entity key (id)`);\n    }\n    return data as T;\n  }\n\n  /** Throw if the action payload is not an array of entities with valid keys */\n  mustBeEntities<T = any>(action: EntityAction<T[]>): T[] {\n    const data = this.extractData(action);\n    if (!Array.isArray(data)) {\n      this.throwError(action, `should be an array of entities`);\n    }\n    data.forEach((entity, i) => {\n      const id = this.selectId(entity);\n      if (this.isNotKeyType(id)) {\n        const msg = `, item ${i + 1}, does not have a valid entity key (id)`;\n        this.throwError(action, msg);\n      }\n    });\n    return data;\n  }\n\n  /** Throw if the action payload is not a single, valid key */\n  mustBeKey(action: EntityAction<string | number>): string | number {\n    const data = this.extractData(action);\n    if (!data) {\n      throw new Error(`should be a single entity key`);\n    }\n    if (this.isNotKeyType(data)) {\n      throw new Error(`is not a valid key (id)`);\n    }\n    return data;\n  }\n\n  /** Throw if the action payload is not an array of valid keys */\n  mustBeKeys(action: EntityAction<(string | number)[]>): (string | number)[] {\n    const data = this.extractData(action);\n    if (!Array.isArray(data)) {\n      this.throwError(action, `should be an array of entity keys (id)`);\n    }\n    data.forEach((id, i) => {\n      if (this.isNotKeyType(id)) {\n        const msg = `${this.entityName} ', item ${i + 1}, is not a valid entity key (id)`;\n        this.throwError(action, msg);\n      }\n    });\n    return data;\n  }\n\n  /** Throw if the action payload is not an update with a valid key (id) */\n  mustBeUpdate<T = any>(action: EntityAction<Update<T>>): Update<T> {\n    const data = this.extractData(action);\n    if (!data) {\n      this.throwError(action, `should be a single entity update`);\n    }\n    const { id, changes } = data;\n    const id2 = this.selectId(changes);\n    if (this.isNotKeyType(id) || this.isNotKeyType(id2)) {\n      this.throwError(action, `has a missing or invalid entity key (id)`);\n    }\n    return data;\n  }\n\n  /** Throw if the action payload is not an array of updates with valid keys (ids) */\n  mustBeUpdates<T = any>(action: EntityAction<Update<any>[]>): Update<T>[] {\n    const data = this.extractData(action);\n    if (!Array.isArray(data)) {\n      this.throwError(action, `should be an array of entity updates`);\n    }\n    data.forEach((item, i) => {\n      const { id, changes } = item;\n      const id2 = this.selectId(changes);\n      if (this.isNotKeyType(id) || this.isNotKeyType(id2)) {\n        this.throwError(action, `, item ${i + 1}, has a missing or invalid entity key (id)`);\n      }\n    });\n    return data;\n  }\n\n  /** Throw if the action payload is not an update response with a valid key (id) */\n  mustBeUpdateResponse<T = any>(action: EntityAction<UpdateResponseData<T>>): UpdateResponseData<T> {\n    const data = this.extractData(action);\n    if (!data) {\n      this.throwError(action, `should be a single entity update`);\n    }\n    const { id, changes } = data;\n    const id2 = this.selectId(changes);\n    if (this.isNotKeyType(id) || this.isNotKeyType(id2)) {\n      this.throwError(action, `has a missing or invalid entity key (id)`);\n    }\n    return data;\n  }\n\n  /** Throw if the action payload is not an array of update responses with valid keys (ids) */\n  mustBeUpdateResponses<T = any>(action: EntityAction<UpdateResponseData<any>[]>): UpdateResponseData<T>[] {\n    const data = this.extractData(action);\n    if (!Array.isArray(data)) {\n      this.throwError(action, `should be an array of entity updates`);\n    }\n    data.forEach((item, i) => {\n      const { id, changes } = item;\n      const id2 = this.selectId(changes);\n      if (this.isNotKeyType(id) || this.isNotKeyType(id2)) {\n        this.throwError(action, `, item ${i + 1}, has a missing or invalid entity key (id)`);\n      }\n    });\n    return data;\n  }\n\n  private extractData<T>(action: EntityAction<T>) {\n    return action.payload && action.payload.data;\n  }\n\n  /** Return true if this key (id) is invalid */\n  private isNotKeyType(id: any) {\n    return typeof id !== 'string' && typeof id !== 'number';\n  }\n\n  private throwError(action: EntityAction, msg: string): void {\n    throw new Error(`${this.entityName} EntityAction guard for \"${action.type}\": payload ${msg}`);\n  }\n}\n","import { IdSelector, Update } from './ngrx-entity-models';\n\n/**\n * Default function that returns the entity's primary key (pkey).\n * Assumes that the entity has an `id` pkey property.\n * Returns `undefined` if no entity or `id`.\n * Every selectId fn must return `undefined` when it cannot produce a full pkey.\n */\nexport function defaultSelectId(entity: any) {\n  return entity == null ? undefined : entity.id;\n}\n\n/**\n * Flatten first arg if it is an array\n * Allows fn with ...rest signature to be called with an array instead of spread\n * Example:\n * ```\n * // See entity-action-operators.ts\n * const persistOps = [EntityOp.QUERY_ALL, EntityOp.ADD, ...];\n * actions.pipe(ofEntityOp(...persistOps)) // works\n * actions.pipe(ofEntityOp(persistOps)) // also works\n * ```\n * */\nexport function flattenArgs<T>(args?: any[]): T[] {\n  if (args == null) {\n    return [];\n  }\n  if (Array.isArray(args[0])) {\n    const [head, ...tail] = args;\n    args = [...head, ...tail];\n  }\n  return args;\n}\n\n/**\n * Return a function that converts an entity (or partial entity) into the `Update<T>`\n * whose `id` is the primary key and\n * `changes` is the entity (or partial entity of changes).\n */\nexport function toUpdateFactory<T>(selectId?: IdSelector<T>) {\n  selectId = selectId || (defaultSelectId as IdSelector<T>);\n  /**\n   * Convert an entity (or partial entity) into the `Update<T>`\n   * whose `id` is the primary key and\n   * `changes` is the entity (or partial entity of changes).\n   * @param selectId function that returns the entity's primary key (id)\n   */\n  return function toUpdate(entity: Partial<T>): Update<T> {\n    const id: any = selectId(entity);\n    if (id == null) {\n      throw new Error('Primary key may not be null/undefined.');\n    }\n    return entity && { id, changes: entity };\n  };\n}\n","import { Action } from '@ngrx/store';\nimport { Actions } from '@ngrx/effects';\n\nimport { Observable, OperatorFunction } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nimport { EntityAction } from './entity-action';\nimport { EntityOp } from './entity-op';\nimport { flattenArgs } from '../utils/utilities';\n\n/**\n * Select actions concerning one of the allowed Entity operations\n * @param allowedEntityOps Entity operations (e.g, EntityOp.QUERY_ALL) whose actions should be selected\n * Example:\n * ```\n *  this.actions.pipe(ofEntityOp(EntityOp.QUERY_ALL, EntityOp.QUERY_MANY), ...)\n *  this.actions.pipe(ofEntityOp(...queryOps), ...)\n *  this.actions.pipe(ofEntityOp(queryOps), ...)\n *  this.actions.pipe(ofEntityOp(), ...) // any action with a defined `entityOp` property\n * ```\n */\nexport function ofEntityOp<T extends EntityAction>(allowedOps: string[] | EntityOp[]): OperatorFunction<EntityAction, T>;\nexport function ofEntityOp<T extends EntityAction>(...allowedOps: (string | EntityOp)[]): OperatorFunction<EntityAction, T>;\nexport function ofEntityOp<T extends EntityAction>(...allowedEntityOps: any[]): OperatorFunction<EntityAction, T> {\n  const ops: string[] = flattenArgs(allowedEntityOps);\n  switch (ops.length) {\n    case 0:\n      return filter((action: EntityAction): action is T => action.payload && action.payload.entityOp != null);\n    case 1:\n      const op = ops[0];\n      return filter((action: EntityAction): action is T => action.payload && op === action.payload.entityOp);\n    default:\n      return filter((action: EntityAction): action is T => {\n        const entityOp = action.payload && action.payload.entityOp;\n        return entityOp && ops.some(o => o === entityOp);\n      });\n  }\n}\n\n/**\n * Select actions concerning one of the allowed Entity types\n * @param allowedEntityNames Entity-type names (e.g, 'Hero') whose actions should be selected\n * Example:\n * ```\n *  this.actions.pipe(ofEntityType(), ...) // ayn EntityAction with a defined entity type property\n *  this.actions.pipe(ofEntityType('Hero'), ...) // EntityActions for the Hero entity\n *  this.actions.pipe(ofEntityType('Hero', 'Villain', 'Sidekick'), ...)\n *  this.actions.pipe(ofEntityType(...theChosen), ...)\n *  this.actions.pipe(ofEntityType(theChosen), ...)\n * ```\n */\nexport function ofEntityType<T extends EntityAction>(allowedEntityNames?: string[]): OperatorFunction<EntityAction, T>;\nexport function ofEntityType<T extends EntityAction>(...allowedEntityNames: string[]): OperatorFunction<EntityAction, T>;\nexport function ofEntityType<T extends EntityAction>(...allowedEntityNames: any[]): OperatorFunction<EntityAction, T> {\n  const names: string[] = flattenArgs(allowedEntityNames);\n  switch (names.length) {\n    case 0:\n      return filter((action: EntityAction): action is T => action.payload && action.payload.entityName != null);\n    case 1:\n      const name = names[0];\n      return filter((action: EntityAction): action is T => action.payload && name === action.payload.entityName);\n    default:\n      return filter((action: EntityAction): action is T => {\n        const entityName = action.payload && action.payload.entityName;\n        return entityName && names.some(n => n === entityName);\n      });\n  }\n}\n","import { Action } from '@ngrx/store';\nimport { EntityActionOptions } from './entity-action';\nimport { EntityCacheAction } from './entity-cache-action';\nimport { Update } from '../utils/ngrx-entity-models';\nimport { DataServiceError } from '../dataservices/data-service-error';\n\nexport enum ChangeSetOperation {\n  Add = 'Add',\n  Delete = 'Delete',\n  Update = 'Update',\n  Upsert = 'Upsert'\n}\nexport interface ChangeSetAdd<T = any> {\n  op: ChangeSetOperation.Add;\n  entityName: string;\n  entities: T[];\n}\n\nexport interface ChangeSetDelete {\n  op: ChangeSetOperation.Delete;\n  entityName: string;\n  entities: string[] | number[];\n}\n\nexport interface ChangeSetUpdate<T = any> {\n  op: ChangeSetOperation.Update;\n  entityName: string;\n  entities: Update<T>[];\n}\n\nexport interface ChangeSetUpsert<T = any> {\n  op: ChangeSetOperation.Upsert;\n  entityName: string;\n  entities: T[];\n}\n\n/**\n * A entities of a single entity type, which are changed in the same way by a ChangeSetOperation\n */\nexport type ChangeSetItem = ChangeSetAdd | ChangeSetDelete | ChangeSetUpdate | ChangeSetUpsert;\n\n/*\n * A set of entity Changes, typically to be saved.\n */\nexport interface ChangeSet<T = any> {\n  /** An array of ChangeSetItems to be processed in the array order */\n  changes: ChangeSetItem[];\n\n  /**\n   * An arbitrary, serializable object that should travel with the ChangeSet.\n   * Meaningful to the ChangeSet producer and consumer. Ignored by ngrx-data.\n   */\n  extras?: T;\n\n  /** An arbitrary string, identifying the ChangeSet and perhaps its purpose */\n  tag?: string;\n}\n\n/**\n * Factory to create a ChangeSetItem for a ChangeSetOperation\n */\nexport class ChangeSetItemFactory {\n  /** Create the ChangeSetAdd for new entities of the given entity type */\n  add<T>(entityName: string, entities: T | T[]): ChangeSetAdd<T> {\n    entities = Array.isArray(entities) ? entities : entities ? [entities] : [];\n    return { entityName, op: ChangeSetOperation.Add, entities };\n  }\n\n  /** Create the ChangeSetDelete for primary keys of the given entity type */\n  delete(entityName: string, keys: number | number[] | string | string[]): ChangeSetDelete {\n    const ids = Array.isArray(keys) ? keys : keys ? ([keys] as string[] | number[]) : [];\n    return { entityName, op: ChangeSetOperation.Delete, entities: ids };\n  }\n\n  /** Create the ChangeSetUpdate for Updates of entities of the given entity type */\n  update<T extends { id: string }>(\n    entityName: string,\n    updates: Update<T> | Update<T>[]\n  ): ChangeSetUpdate<T> {\n    updates = Array.isArray(updates) ? updates : updates ? [updates] : [];\n    return { entityName, op: ChangeSetOperation.Update, entities: updates };\n  }\n\n  /** Create the ChangeSetUpsert for new or existing entities of the given entity type */\n  upsert<T>(entityName: string, entities: T | T[]): ChangeSetUpsert<T> {\n    entities = Array.isArray(entities) ? entities : entities ? [entities] : [];\n    return { entityName, op: ChangeSetOperation.Upsert, entities };\n  }\n}\n\n/**\n * Instance of a factory to create a ChangeSetItem for a ChangeSetOperation\n */\nexport const changeSetItemFactory = new ChangeSetItemFactory();\n\n/**\n * Return ChangeSet after filtering out null and empty ChangeSetItems.\n * @param changeSet ChangeSet with changes to filter\n */\nexport function excludeEmptyChangeSetItems(changeSet: ChangeSet): ChangeSet {\n  changeSet = changeSet && changeSet.changes ? changeSet : { changes: [] };\n  const changes = changeSet.changes.filter(c => c != null && c.entities && c.entities.length > 0);\n  return { ...changeSet, changes };\n}\n","/** How to merge an entity, after query or save, when the corresponding entity in the collection has unsaved changes. */\nexport enum MergeStrategy {\n  /**\n   * Update the collection entities and ignore all change tracking for this operation.\n   * ChangeState is untouched.\n   */\n  IgnoreChanges,\n  /**\n   * Updates current values for unchanged entities.\n   * If entities are changed, preserves their current values and\n   * overwrites their originalValue with the merge entity.\n   * This is the query-success default.\n   */\n  PreserveChanges,\n  /**\n   * Replace the current collection entities.\n   * Discards the ChangeState for the merged entities if set\n   * and their ChangeTypes becomes \"unchanged\".\n   * This is the save-success default.\n   */\n  OverwriteChanges\n}\n","/*\n * Actions dedicated to the EntityCache as a whole\n */\nimport { Action } from '@ngrx/store';\n\nimport { ChangeSet, ChangeSetOperation } from './entity-cache-change-set';\nexport { ChangeSet, ChangeSetOperation } from './entity-cache-change-set';\n\nimport { DataServiceError } from '../dataservices/data-service-error';\nimport { EntityActionOptions } from '../actions/entity-action';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { MergeStrategy } from '../actions/merge-strategy';\n\nexport enum EntityCacheAction {\n  CLEAR_COLLECTIONS = 'ngrx-data/entity-cache/clear-collections',\n  LOAD_COLLECTIONS = 'ngrx-data/entity-cache/load-collections',\n  MERGE_QUERY_SET = 'ngrx-data/entity-cache/merge-query-set',\n  SET_ENTITY_CACHE = 'ngrx-data/entity-cache/set-cache',\n\n  SAVE_ENTITIES = 'ngrx-data/entity-cache/save-entities',\n  SAVE_ENTITIES_CANCEL = 'ngrx-data/entity-cache/save-entities-cancel',\n  SAVE_ENTITIES_CANCELED = 'ngrx-data/entity-cache/save-entities-canceled',\n  SAVE_ENTITIES_ERROR = 'ngrx-data/entity-cache/save-entities-error',\n  SAVE_ENTITIES_SUCCESS = 'ngrx-data/entity-cache/save-entities-success'\n}\n\n/**\n * Hash of entities keyed by EntityCollection name,\n * typically the result of a query that returned results from a multi-collection query\n * that will be merged into an EntityCache via the `MergeQuerySet` action.\n */\nexport interface EntityCacheQuerySet {\n  [entityName: string]: any[];\n}\n\n/**\n * Clear the collections identified in the collectionSet.\n * @param [collections] Array of names of the collections to clear.\n * If empty array, does nothing. If no array, clear all collections.\n * @param [tag] Optional tag to identify the operation from the app perspective.\n */\nexport class ClearCollections implements Action {\n  readonly payload: { collections: string[]; tag: string };\n  readonly type = EntityCacheAction.CLEAR_COLLECTIONS;\n\n  constructor(collections?: string[], tag?: string) {\n    this.payload = { collections, tag };\n  }\n}\n\n/**\n * Create entity cache action that loads multiple entity collections at the same time.\n * before any selectors$ observables emit.\n * @param querySet The collections to load, typically the result of a query.\n * @param [tag] Optional tag to identify the operation from the app perspective.\n * in the form of a map of entity collections.\n */\nexport class LoadCollections implements Action {\n  readonly payload: { collections: EntityCacheQuerySet; tag: string };\n  readonly type = EntityCacheAction.LOAD_COLLECTIONS;\n\n  constructor(collections: EntityCacheQuerySet, tag?: string) {\n    this.payload = { collections, tag };\n  }\n}\n\n/**\n * Create entity cache action that merges entities from a query result\n * that returned entities from multiple collections.\n * Corresponding entity cache reducer should add and update all collections\n * at the same time, before any selectors$ observables emit.\n * @param querySet The result of the query in the form of a map of entity collections.\n * These are the entity data to merge into the respective collections.\n * @param mergeStrategy How to merge a queried entity when it is already in the collection.\n * The default is MergeStrategy.PreserveChanges\n * @param [tag] Optional tag to identify the operation from the app perspective.\n */\nexport class MergeQuerySet implements Action {\n  readonly payload: {\n    querySet: EntityCacheQuerySet;\n    mergeStrategy?: MergeStrategy;\n    tag?: string;\n  };\n\n  readonly type = EntityCacheAction.MERGE_QUERY_SET;\n\n  constructor(querySet: EntityCacheQuerySet, mergeStrategy?: MergeStrategy, tag?: string) {\n    this.payload = {\n      querySet,\n      mergeStrategy: mergeStrategy === null ? MergeStrategy.PreserveChanges : mergeStrategy,\n      tag\n    };\n  }\n}\n\n/**\n * Create entity cache action for replacing the entire entity cache.\n * Dangerous because brute force but useful as when re-hydrating an EntityCache\n * from local browser storage when the application launches.\n * @param cache New state of the entity cache\n * @param [tag] Optional tag to identify the operation from the app perspective.\n */\nexport class SetEntityCache implements Action {\n  readonly payload: { cache: EntityCache; tag: string };\n  readonly type = EntityCacheAction.SET_ENTITY_CACHE;\n\n  constructor(public readonly cache: EntityCache, tag?: string) {\n    this.payload = { cache, tag };\n  }\n}\n\n// #region SaveEntities\nexport class SaveEntities implements Action {\n  readonly payload: {\n    readonly changeSet: ChangeSet;\n    readonly url: string;\n    readonly correlationId?: any;\n    readonly isOptimistic?: boolean;\n    readonly mergeStrategy?: MergeStrategy;\n    readonly tag?: string;\n    error?: Error;\n    skip?: boolean; // not used\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES;\n\n  constructor(changeSet: ChangeSet, url: string, options?: EntityActionOptions) {\n    options = options || {};\n    if (changeSet) {\n      changeSet.tag = changeSet.tag || options.tag;\n    }\n    this.payload = { changeSet, url, ...options, tag: changeSet.tag };\n  }\n}\n\nexport class SaveEntitiesCancel implements Action {\n  readonly payload: {\n    readonly correlationId: any;\n    readonly reason: string;\n    readonly entityNames: string[];\n    readonly tag?: string;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_CANCEL;\n\n  constructor(correlationId: any, reason?: string, entityNames?: string[], tag?: string) {\n    this.payload = { correlationId, reason, entityNames, tag };\n  }\n}\n\nexport class SaveEntitiesCanceled implements Action {\n  readonly payload: {\n    readonly correlationId: any;\n    readonly reason: string;\n    readonly tag?: string;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_CANCEL;\n\n  constructor(correlationId: any, reason?: string, tag?: string) {\n    this.payload = { correlationId, reason, tag };\n  }\n}\n\nexport class SaveEntitiesError {\n  readonly payload: {\n    readonly error: DataServiceError;\n    readonly originalAction: SaveEntities;\n    readonly correlationId: any;\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_ERROR;\n  constructor(error: DataServiceError, originalAction: SaveEntities) {\n    const correlationId = originalAction.payload.correlationId;\n    this.payload = { error, originalAction, correlationId };\n  }\n}\n\nexport class SaveEntitiesSuccess implements Action {\n  readonly payload: {\n    readonly changeSet: ChangeSet;\n    readonly url: string;\n    readonly correlationId?: any;\n    readonly isOptimistic?: boolean;\n    readonly mergeStrategy?: MergeStrategy;\n    readonly tag?: string;\n    error?: Error;\n    skip?: boolean; // not used\n  };\n  readonly type = EntityCacheAction.SAVE_ENTITIES_SUCCESS;\n\n  constructor(changeSet: ChangeSet, url: string, options?: EntityActionOptions) {\n    options = options || {};\n    if (changeSet) {\n      changeSet.tag = changeSet.tag || options.tag;\n    }\n    this.payload = { changeSet, url, ...options, tag: changeSet.tag };\n  }\n}\n// #endregion SaveEntities\n","// Ensure that these suffix values and the EntityOp suffixes match\n// Cannot do that programmatically.\n\n/** General purpose entity action operations, good for any entity type */\nexport enum EntityOp {\n  // Persistance operations\n  CANCEL_PERSIST = 'ngrx-data/cancel-persist',\n  CANCELED_PERSIST = 'ngrx-data/canceled-persist',\n\n  QUERY_ALL = 'ngrx-data/query-all',\n  QUERY_ALL_SUCCESS = 'ngrx-data/query-all/success',\n  QUERY_ALL_ERROR = 'ngrx-data/query-all/error',\n\n  QUERY_LOAD = 'ngrx-data/query-load',\n  QUERY_LOAD_SUCCESS = 'ngrx-data/query-load/success',\n  QUERY_LOAD_ERROR = 'ngrx-data/query-load/error',\n\n  QUERY_MANY = 'ngrx-data/query-many',\n  QUERY_MANY_SUCCESS = 'ngrx-data/query-many/success',\n  QUERY_MANY_ERROR = 'ngrx-data/query-many/error',\n\n  QUERY_BY_KEY = 'ngrx-data/query-by-key',\n  QUERY_BY_KEY_SUCCESS = 'ngrx-data/query-by-key/success',\n  QUERY_BY_KEY_ERROR = 'ngrx-data/query-by-key/error',\n\n  SAVE_ADD_MANY = 'ngrx-data/save/add-many',\n  SAVE_ADD_MANY_ERROR = 'ngrx-data/save/add-many/error',\n  SAVE_ADD_MANY_SUCCESS = 'ngrx-data/save/add-many/success',\n\n  SAVE_ADD_ONE = 'ngrx-data/save/add-one',\n  SAVE_ADD_ONE_ERROR = 'ngrx-data/save/add-one/error',\n  SAVE_ADD_ONE_SUCCESS = 'ngrx-data/save/add-one/success',\n\n  SAVE_DELETE_MANY = 'ngrx-data/save/delete-many',\n  SAVE_DELETE_MANY_SUCCESS = 'ngrx-data/save/delete-many/success',\n  SAVE_DELETE_MANY_ERROR = 'ngrx-data/save/delete-many/error',\n\n  SAVE_DELETE_ONE = 'ngrx-data/save/delete-one',\n  SAVE_DELETE_ONE_SUCCESS = 'ngrx-data/save/delete-one/success',\n  SAVE_DELETE_ONE_ERROR = 'ngrx-data/save/delete-one/error',\n\n  SAVE_UPDATE_MANY = 'ngrx-data/save/update-many',\n  SAVE_UPDATE_MANY_SUCCESS = 'ngrx-data/save/update-many/success',\n  SAVE_UPDATE_MANY_ERROR = 'ngrx-data/save/update-many/error',\n\n  SAVE_UPDATE_ONE = 'ngrx-data/save/update-one',\n  SAVE_UPDATE_ONE_SUCCESS = 'ngrx-data/save/update-one/success',\n  SAVE_UPDATE_ONE_ERROR = 'ngrx-data/save/update-one/error',\n\n  // Use only if the server supports upsert;\n  SAVE_UPSERT_MANY = 'ngrx-data/save/upsert-many',\n  SAVE_UPSERT_MANY_SUCCESS = 'ngrx-data/save/upsert-many/success',\n  SAVE_UPSERT_MANY_ERROR = 'ngrx-data/save/upsert-many/error',\n\n  // Use only if the server supports upsert;\n  SAVE_UPSERT_ONE = 'ngrx-data/save/upsert-one',\n  SAVE_UPSERT_ONE_SUCCESS = 'ngrx-data/save/upsert-one/success',\n  SAVE_UPSERT_ONE_ERROR = 'ngrx-data/save/upsert-one/error',\n\n  // Cache operations\n  ADD_ALL = 'ngrx-data/add-all',\n  ADD_MANY = 'ngrx-data/add-many',\n  ADD_ONE = 'ngrx-data/add-one',\n  REMOVE_ALL = 'ngrx-data/remove-all',\n  REMOVE_MANY = 'ngrx-data/remove-many',\n  REMOVE_ONE = 'ngrx-data/remove-one',\n  UPDATE_MANY = 'ngrx-data/update-many',\n  UPDATE_ONE = 'ngrx-data/update-one',\n  UPSERT_MANY = 'ngrx-data/upsert-many',\n  UPSERT_ONE = 'ngrx-data/upsert-one',\n\n  COMMIT_ALL = 'ngrx-data/commit-all',\n  COMMIT_MANY = 'ngrx-data/commit-many',\n  COMMIT_ONE = 'ngrx-data/commit-one',\n  UNDO_ALL = 'ngrx-data/undo-all',\n  UNDO_MANY = 'ngrx-data/undo-many',\n  UNDO_ONE = 'ngrx-data/undo-one',\n\n  SET_CHANGE_STATE = 'ngrx-data/set-change-state',\n  SET_COLLECTION = 'ngrx-data/set-collection',\n  SET_FILTER = 'ngrx-data/set-filter',\n  SET_LOADED = 'ngrx-data/set-loaded',\n  SET_LOADING = 'ngrx-data/set-loading'\n}\n\n/** \"Success\" suffix appended to EntityOps that are successful.*/\nexport const OP_SUCCESS = '/success';\n\n/** \"Error\" suffix appended to EntityOps that have failed.*/\nexport const OP_ERROR = '/error';\n\n/** Make the error EntityOp corresponding to the given EntityOp */\nexport function makeErrorOp(op: EntityOp): EntityOp {\n  return <EntityOp>(op + OP_ERROR);\n}\n\n/** Make the success EntityOp corresponding to the given EntityOp */\nexport function makeSuccessOp(op: EntityOp): EntityOp {\n  return <EntityOp>(op + OP_SUCCESS);\n}\n","import { EntityAction } from '../actions/entity-action';\nimport { RequestData } from './interfaces';\n\n/**\n * Error from a DataService\n * The source error either comes from a failed HTTP response or was thrown within the service.\n * @param error the HttpErrorResponse or the error thrown by the service\n * @param requestData the HTTP request information such as the method and the url.\n */\n// If extend from Error, `dse instanceof DataServiceError` returns false\n// in some (all?) unit tests so don't bother trying.\nexport class DataServiceError {\n  message: string;\n\n  constructor(public error: any, public requestData: RequestData) {\n    this.message = typeof error === 'string' ? error : extractMessage(error);\n  }\n}\n\n// Many ways the error can be shaped. These are the ways we recognize.\nfunction extractMessage(sourceError: any) {\n  const { error, body, message } = sourceError;\n  let errMessage: string;\n  if (error) {\n    // prefer HttpErrorResponse.error to its message property\n    errMessage = typeof error === 'string' ? error : error.message;\n  } else if (message) {\n    errMessage = message;\n  } else if (body) {\n    // try the body if no error or message property\n    errMessage = typeof body === 'string' ? body : body.error;\n  }\n\n  return typeof errMessage === 'string'\n    ? errMessage\n    : errMessage\n      ? JSON.stringify(errMessage)\n      : null;\n}\n\n/** Payload for an EntityAction data service error such as QUERY_ALL_ERROR */\nexport interface EntityActionDataServiceError {\n  error: DataServiceError;\n  originalAction: EntityAction;\n}\n","import { HttpUrlGenerator, EntityHttpResourceUrls } from './http-url-generator';\n\n/**\n * Optional configuration settings for an entity collection data service\n * such as the `DefaultDataService<T>`.\n */\nexport abstract class DefaultDataServiceConfig {\n  /** root path of the web api (default: 'api') */\n  root?: string;\n  /**\n   * Known entity HttpResourceUrls.\n   * HttpUrlGenerator will create these URLs for entity types not listed here.\n   */\n  entityHttpResourceUrls?: EntityHttpResourceUrls;\n  /** Is a DELETE 404 really OK? (default: true) */\n  delete404OK?: boolean;\n  /** Simulate GET latency in a demo (default: 0) */\n  getDelay?: number;\n  /** Simulate save method (PUT/POST/DELETE) latency in a demo (default: 0) */\n  saveDelay?: number;\n  /** request timeout in MS (default: 0)*/\n  timeout?: number; //\n}\n","import { InjectionToken } from '@angular/core';\n\nexport abstract class Logger {\n  abstract error(message?: any, ...optionalParams: any[]): void;\n  abstract log(message?: any, ...optionalParams: any[]): void;\n  abstract warn(message?: any, ...optionalParams: any[]): void;\n}\n\n/**\n * Mapping of entity type name to its plural\n */\nexport interface EntityPluralNames {\n  [entityName: string]: string;\n}\n\nexport const PLURAL_NAMES_TOKEN = new InjectionToken<EntityPluralNames>(\n  'ngrx-data/plural-names'\n);\n\nexport abstract class Pluralizer {\n  abstract pluralize(name: string): string;\n}\n","import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { Pluralizer } from '../utils/interfaces';\n\n/**\n * Known resource URLS for specific entity types.\n * Each entity's resource URLS are endpoints that\n * target single entity and multi-entity HTTP operations.\n * Used by the `DefaultHttpUrlGenerator`.\n */\nexport abstract class EntityHttpResourceUrls {\n  [entityName: string]: HttpResourceUrls;\n}\n\n/**\n * Resource URLS for HTTP operations that target single entity\n * and multi-entity endpoints.\n */\nexport interface HttpResourceUrls {\n  /**\n   * The URL path for a single entity endpoint, e.g, `some-api-root/hero/`\n   * such as you'd use to add a hero.\n   * Example: `httpClient.post<Hero>('some-api-root/hero/', addedHero)`.\n   * Note trailing slash (/).\n   */\n  entityResourceUrl: string;\n  /**\n   * The URL path for a multiple-entity endpoint, e.g, `some-api-root/heroes/`\n   * such as you'd use when getting all heroes.\n   * Example: `httpClient.get<Hero[]>('some-api-root/heroes/')`\n   * Note trailing slash (/).\n   */\n  collectionResourceUrl: string;\n}\n\n/**\n * Generate the base part of an HTTP URL for\n * single entity or entity collection resource\n */\nexport abstract class HttpUrlGenerator {\n  /**\n   * Return the base URL for a single entity resource,\n   * e.g., the base URL to get a single hero by its id\n   */\n  abstract entityResource(entityName: string, root: string): string;\n\n  /**\n   * Return the base URL for a collection resource,\n   * e.g., the base URL to get all heroes\n   */\n  abstract collectionResource(entityName: string, root: string): string;\n\n  /**\n   * Register known single-entity and collection resource URLs for HTTP calls\n   * @param entityHttpResourceUrls {EntityHttpResourceUrls} resource urls for specific entity type names\n   */\n  abstract registerHttpResourceUrls(\n    entityHttpResourceUrls: EntityHttpResourceUrls\n  ): void;\n}\n\n@Injectable()\nexport class DefaultHttpUrlGenerator implements HttpUrlGenerator {\n  /**\n   * Known single-entity and collection resource URLs for HTTP calls.\n   * Generator methods returns these resource URLs for a given entity type name.\n   * If the resources for an entity type name are not know, it generates\n   * and caches a resource name for future use\n   */\n  protected knownHttpResourceUrls: EntityHttpResourceUrls = {};\n\n  constructor(private pluralizer: Pluralizer) {}\n\n  /**\n   * Get or generate the entity and collection resource URLs for the given entity type name\n   * @param entityName {string} Name of the entity type, e.g, 'Hero'\n   * @param root {string} Root path to the resource, e.g., 'some-api`\n   */\n  protected getResourceUrls(\n    entityName: string,\n    root: string\n  ): HttpResourceUrls {\n    let resourceUrls = this.knownHttpResourceUrls[entityName];\n    if (!resourceUrls) {\n      const nRoot = normalizeRoot(root);\n      resourceUrls = {\n        entityResourceUrl: `${nRoot}/${entityName}/`.toLowerCase(),\n        collectionResourceUrl: `${nRoot}/${this.pluralizer.pluralize(\n          entityName\n        )}/`.toLowerCase()\n      };\n      this.registerHttpResourceUrls({ [entityName]: resourceUrls });\n    }\n    return resourceUrls;\n  }\n\n  /**\n   * Create the path to a single entity resource\n   * @param entityName {string} Name of the entity type, e.g, 'Hero'\n   * @param root {string} Root path to the resource, e.g., 'some-api`\n   * @returns complete path to resource, e.g, 'some-api/hero'\n   */\n  entityResource(entityName: string, root: string): string {\n    return this.getResourceUrls(entityName, root).entityResourceUrl;\n  }\n\n  /**\n   * Create the path to a multiple entity (collection) resource\n   * @param entityName {string} Name of the entity type, e.g, 'Hero'\n   * @param root {string} Root path to the resource, e.g., 'some-api`\n   * @returns complete path to resource, e.g, 'some-api/heroes'\n   */\n  collectionResource(entityName: string, root: string): string {\n    return this.getResourceUrls(entityName, root).collectionResourceUrl;\n  }\n\n  /**\n   * Register known single-entity and collection resource URLs for HTTP calls\n   * @param entityHttpResourceUrls {EntityHttpResourceUrls} resource urls for specific entity type names\n   * Well-formed resource urls end in a '/';\n   * Note: this method does not ensure that resource urls are well-formed.\n   */\n  registerHttpResourceUrls(\n    entityHttpResourceUrls: EntityHttpResourceUrls\n  ): void {\n    this.knownHttpResourceUrls = {\n      ...this.knownHttpResourceUrls,\n      ...(entityHttpResourceUrls || {})\n    };\n  }\n}\n\n/** Remove leading & trailing spaces or slashes */\nexport function normalizeRoot(root: string) {\n  return root.replace(/^[\\/\\s]+|[\\/\\s]+$/g, '');\n}\n","import { Injectable, Optional } from '@angular/core';\nimport { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';\n\nimport { Observable, of, throwError } from 'rxjs';\nimport { catchError, delay, map, tap, timeout } from 'rxjs/operators';\n\nimport { DataServiceError } from './data-service-error';\nimport { DefaultDataServiceConfig } from './default-data-service-config';\nimport { EntityCollectionDataService, HttpMethods, QueryParams, RequestData } from './interfaces';\nimport { HttpUrlGenerator } from './http-url-generator';\nimport { Update } from '../utils/ngrx-entity-models';\n\n/**\n * A basic, generic entity data service\n * suitable for persistence of most entities.\n * Assumes a common REST-y web API\n */\nexport class DefaultDataService<T> implements EntityCollectionDataService<T> {\n  protected _name: string;\n  protected delete404OK: boolean;\n  protected entityName: string;\n  protected entityUrl: string;\n  protected entitiesUrl: string;\n  protected getDelay = 0;\n  protected saveDelay = 0;\n  protected timeout = 0;\n\n  get name() {\n    return this._name;\n  }\n\n  constructor(\n    entityName: string,\n    protected http: HttpClient,\n    protected httpUrlGenerator: HttpUrlGenerator,\n    config?: DefaultDataServiceConfig\n  ) {\n    this._name = `${entityName} DefaultDataService`;\n    this.entityName = entityName;\n    const { root = 'api', delete404OK = true, getDelay = 0, saveDelay = 0, timeout: to = 0 } = config || {};\n    this.delete404OK = delete404OK;\n    this.entityUrl = httpUrlGenerator.entityResource(entityName, root);\n    this.entitiesUrl = httpUrlGenerator.collectionResource(entityName, root);\n    this.getDelay = getDelay;\n    this.saveDelay = saveDelay;\n    this.timeout = to;\n  }\n\n  add(entity: T): Observable<T> {\n    const entityOrError = entity || new Error(`No \"${this.entityName}\" entity to add`);\n    return this.execute('POST', this.entityUrl, entityOrError);\n  }\n\n  delete(key: number | string): Observable<number | string> {\n    let err: Error;\n    if (key == null) {\n      err = new Error(`No \"${this.entityName}\" key to delete`);\n    }\n    return this.execute('DELETE', this.entityUrl + key, err).pipe(\n      // forward the id of deleted entity as the result of the HTTP DELETE\n      map(result => key as number | string)\n    );\n  }\n\n  getAll(): Observable<T[]> {\n    return this.execute('GET', this.entitiesUrl);\n  }\n\n  getById(key: number | string): Observable<T> {\n    let err: Error;\n    if (key == null) {\n      err = new Error(`No \"${this.entityName}\" key to get`);\n    }\n    return this.execute('GET', this.entityUrl + key, err);\n  }\n\n  getWithQuery(queryParams: QueryParams | string): Observable<T[]> {\n    const qParams = typeof queryParams === 'string' ? { fromString: queryParams } : { fromObject: queryParams };\n    const params = new HttpParams(qParams);\n    return this.execute('GET', this.entitiesUrl, undefined, { params });\n  }\n\n  update(update: Update<T>): Observable<T> {\n    const id = update && update.id;\n    const updateOrError = id == null ? new Error(`No \"${this.entityName}\" update data or id`) : update.changes;\n    return this.execute('PUT', this.entityUrl + id, updateOrError);\n  }\n\n  // Important! Only call if the backend service supports upserts as a POST to the target URL\n  upsert(entity: T): Observable<T> {\n    const entityOrError = entity || new Error(`No \"${this.entityName}\" entity to upsert`);\n    return this.execute('POST', this.entityUrl, entityOrError);\n  }\n\n  protected execute(\n    method: HttpMethods,\n    url: string,\n    data?: any, // data, error, or undefined/null\n    options?: any\n  ): Observable<any> {\n    const req: RequestData = { method, url, data, options };\n\n    if (data instanceof Error) {\n      return this.handleError(req)(data);\n    }\n\n    let result$: Observable<ArrayBuffer>;\n\n    switch (method) {\n      case 'DELETE': {\n        result$ = this.http.delete(url, options);\n        if (this.saveDelay) {\n          result$ = result$.pipe(delay(this.saveDelay));\n        }\n        break;\n      }\n      case 'GET': {\n        result$ = this.http.get(url, options);\n        if (this.getDelay) {\n          result$ = result$.pipe(delay(this.getDelay));\n        }\n        break;\n      }\n      case 'POST': {\n        result$ = this.http.post(url, data, options);\n        if (this.saveDelay) {\n          result$ = result$.pipe(delay(this.saveDelay));\n        }\n        break;\n      }\n      // N.B.: It must return an Update<T>\n      case 'PUT': {\n        result$ = this.http.put(url, data, options);\n        if (this.saveDelay) {\n          result$ = result$.pipe(delay(this.saveDelay));\n        }\n        break;\n      }\n      default: {\n        const error = new Error('Unimplemented HTTP method, ' + method);\n        result$ = throwError(error);\n      }\n    }\n    if (this.timeout) {\n      result$ = result$.pipe(timeout(this.timeout + this.saveDelay));\n    }\n    return result$.pipe(catchError(this.handleError(req)));\n  }\n\n  private handleError(reqData: RequestData) {\n    return (err: any) => {\n      const ok = this.handleDelete404(err, reqData);\n      if (ok) {\n        return ok;\n      }\n      const error = new DataServiceError(err, reqData);\n      return throwError(error);\n    };\n  }\n\n  private handleDelete404(error: HttpErrorResponse, reqData: RequestData) {\n    if (error.status === 404 && reqData.method === 'DELETE' && this.delete404OK) {\n      return of({});\n    }\n    return undefined;\n  }\n}\n\n/**\n * Create a basic, generic entity data service\n * suitable for persistence of most entities.\n * Assumes a common REST-y web API\n */\n@Injectable()\nexport class DefaultDataServiceFactory {\n  constructor(\n    protected http: HttpClient,\n    protected httpUrlGenerator: HttpUrlGenerator,\n    @Optional() protected config?: DefaultDataServiceConfig\n  ) {\n    config = config || {};\n    httpUrlGenerator.registerHttpResourceUrls(config.entityHttpResourceUrls);\n  }\n\n  /**\n   * Create a default {EntityCollectionDataService} for the given entity type\n   * @param entityName {string} Name of the entity type for this data service\n   */\n  create<T>(entityName: string): EntityCollectionDataService<T> {\n    return new DefaultDataService<T>(entityName, this.http, this.httpUrlGenerator, this.config);\n  }\n}\n","import { EntityState, EntityAdapter, createEntityAdapter } from '@ngrx/entity';\n\nimport { EntitySelectors, EntitySelectorsFactory } from '../selectors/entity-selectors';\nimport { Comparer, Dictionary, IdSelector, Update } from '../utils/ngrx-entity-models';\nimport { EntityDispatcherDefaultOptions } from '../dispatchers/entity-dispatcher-default-options';\nimport { defaultSelectId } from '../utils/utilities';\nimport { EntityCollection } from '../reducers/entity-collection';\nimport { EntityFilterFn } from './entity-filters';\nimport { EntityMetadata } from './entity-metadata';\n\nexport interface EntityDefinition<T = any> {\n  entityName: string;\n  entityAdapter: EntityAdapter<T>;\n  entityDispatcherOptions?: Partial<EntityDispatcherDefaultOptions>;\n  initialState: EntityCollection<T>;\n  metadata: EntityMetadata<T>;\n  noChangeTracking: boolean;\n  selectId: IdSelector<T>;\n  sortComparer: false | Comparer<T>;\n}\n\nexport function createEntityDefinition<T, S extends object>(metadata: EntityMetadata<T, S>): EntityDefinition<T> {\n  let entityName = metadata.entityName;\n  if (!entityName) {\n    throw new Error('Missing required entityName');\n  }\n  metadata.entityName = entityName = entityName.trim();\n  const selectId = metadata.selectId || defaultSelectId;\n  const sortComparer = (metadata.sortComparer = metadata.sortComparer || false);\n\n  const entityAdapter = createEntityAdapter<T>({ selectId, sortComparer });\n\n  const entityDispatcherOptions: Partial<EntityDispatcherDefaultOptions> = metadata.entityDispatcherOptions || {};\n\n  const initialState: EntityCollection<T> = entityAdapter.getInitialState({\n    entityName,\n    filter: '',\n    loaded: false,\n    loading: false,\n    changeState: {},\n    ...(metadata.additionalCollectionState || {})\n  });\n\n  const noChangeTracking = metadata.noChangeTracking === true; // false by default\n\n  return {\n    entityName,\n    entityAdapter,\n    entityDispatcherOptions,\n    initialState,\n    metadata,\n    noChangeTracking,\n    selectId,\n    sortComparer\n  };\n}\n","import { InjectionToken } from '@angular/core';\nimport { EntityDispatcherDefaultOptions } from '../dispatchers/entity-dispatcher-default-options';\nimport { EntityFilterFn } from './entity-filters';\nimport { IdSelector, Comparer } from '../utils/ngrx-entity-models';\n\nexport const ENTITY_METADATA_TOKEN = new InjectionToken<EntityMetadataMap>('ngrx-data/entity-metadata');\n\n/** Metadata that describe an entity type and its collection to ngrx-data */\nexport interface EntityMetadata<T = any, S extends object = {}> {\n  entityName: string;\n  entityDispatcherOptions?: Partial<EntityDispatcherDefaultOptions>;\n  filterFn?: EntityFilterFn<T>;\n  noChangeTracking?: boolean;\n  selectId?: IdSelector<T>;\n  sortComparer?: false | Comparer<T>;\n  additionalCollectionState?: S;\n}\n\n/** Map entity-type name to its EntityMetadata */\nexport interface EntityMetadataMap {\n  [entityName: string]: Partial<EntityMetadata<any>>;\n}\n","import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\n\nimport { createEntityDefinition, EntityDefinition } from './entity-definition';\nimport { EntityMetadata, EntityMetadataMap, ENTITY_METADATA_TOKEN } from './entity-metadata';\nimport { ENTITY_CACHE_NAME } from '../reducers/constants';\n\nexport interface EntityDefinitions {\n  [entityName: string]: EntityDefinition<any>;\n}\n\n/** Registry of EntityDefinitions for all cached entity types */\n@Injectable()\nexport class EntityDefinitionService {\n  /** {EntityDefinition} for all cached entity types */\n  private readonly definitions: EntityDefinitions = {};\n\n  constructor(\n    @Optional()\n    @Inject(ENTITY_METADATA_TOKEN)\n    entityMetadataMaps: EntityMetadataMap[]\n  ) {\n    if (entityMetadataMaps) {\n      entityMetadataMaps.forEach(map => this.registerMetadataMap(map));\n    }\n  }\n\n  /**\n   * Get (or create) a data service for entity type\n   * @param entityName - the name of the type\n   *\n   * Examples:\n   *   getDefinition('Hero'); // definition for Heroes, untyped\n   *   getDefinition<Hero>(`Hero`); // definition for Heroes, typed with Hero interface\n   */\n  getDefinition<T>(entityName: string, shouldThrow = true): EntityDefinition<T> {\n    entityName = entityName.trim();\n    const definition = this.definitions[entityName];\n    if (!definition && shouldThrow) {\n      throw new Error(`No EntityDefinition for entity type \"${entityName}\".`);\n    }\n    return definition;\n  }\n\n  //////// Registration methods //////////\n\n  /**\n   * Create and register the {EntityDefinition} for the {EntityMetadata} of an entity type\n   * @param name - the name of the entity type\n   * @param definition - {EntityMetadata} for a collection for that entity type\n   *\n   * Examples:\n   *   registerMetadata(myHeroEntityDefinition);\n   */\n  registerMetadata(metadata: EntityMetadata) {\n    if (metadata) {\n      const definition = createEntityDefinition(metadata);\n      this.registerDefinition(definition);\n    }\n  }\n\n  /**\n   * Register an EntityMetadataMap.\n   * @param metadataMap - a map of entityType names to entity metadata\n   *\n   * Examples:\n   *   registerMetadataMap({\n   *     'Hero': myHeroMetadata,\n   *     Villain: myVillainMetadata\n   *   });\n   */\n  registerMetadataMap(metadataMap: EntityMetadataMap = {}) {\n    // The entity type name should be the same as the map key\n    Object.keys(metadataMap || {}).forEach(entityName => this.registerMetadata({ entityName, ...metadataMap[entityName] }));\n  }\n\n  /**\n   * Register an {EntityDefinition} for an entity type\n   * @param definition - EntityDefinition of a collection for that entity type\n   *\n   * Examples:\n   *   registerDefinition('Hero', myHeroEntityDefinition);\n   */\n  registerDefinition<T>(definition: EntityDefinition<T>) {\n    this.definitions[definition.entityName] = definition;\n  }\n\n  /**\n   * Register a batch of EntityDefinitions.\n   * @param definitions - map of entityType name and associated EntityDefinitions to merge.\n   *\n   * Examples:\n   *   registerDefinitions({\n   *     'Hero': myHeroEntityDefinition,\n   *     Villain: myVillainEntityDefinition\n   *   });\n   */\n  registerDefinitions(definitions: EntityDefinitions) {\n    Object.assign(this.definitions, definitions);\n  }\n}\n","import { Injectable, Optional } from '@angular/core';\nimport { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';\n\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, delay, map, timeout } from 'rxjs/operators';\n\nimport {\n  ChangeSetOperation,\n  ChangeSet,\n  ChangeSetItem,\n  ChangeSetUpdate,\n  excludeEmptyChangeSetItems\n} from '../actions/entity-cache-change-set';\nimport { DataServiceError } from './data-service-error';\nimport { DefaultDataServiceConfig } from './default-data-service-config';\nimport { EntityDefinitionService } from '../entity-metadata/entity-definition.service';\nimport { IdSelector } from '../utils/ngrx-entity-models';\nimport { RequestData } from './interfaces';\n\nconst updateOp = ChangeSetOperation.Update;\n\n/**\n * Default data service for making remote service calls targeting the entire EntityCache.\n * See EntityDataService for services that target a single EntityCollection\n */\n@Injectable()\nexport class EntityCacheDataService {\n  protected idSelectors: { [entityName: string]: IdSelector<any> } = {};\n  protected saveDelay = 0;\n  protected timeout = 0;\n\n  constructor(\n    protected entityDefinitionService: EntityDefinitionService,\n    protected http: HttpClient,\n    @Optional() config?: DefaultDataServiceConfig\n  ) {\n    const { saveDelay = 0, timeout: to = 0 } = config || {};\n    this.saveDelay = saveDelay;\n    this.timeout = to;\n  }\n\n  /**\n   * Save changes to multiple entities across one or more entity collections.\n   * Server endpoint must understand the essential SaveEntities protocol,\n   * in particular the ChangeSet interface (except for Update<T>).\n   * This implementation extracts the entity changes from a ChangeSet Update<T>[] and sends those.\n   * It then reconstructs Update<T>[] in the returned observable result.\n   * @param changeSet  An array of SaveEntityItems.\n   * Each SaveEntityItem describe a change operation for one or more entities of a single collection,\n   * known by its 'entityName'.\n   * @param url The server endpoint that receives this request.\n   */\n  saveEntities(changeSet: ChangeSet, url: string): Observable<ChangeSet> {\n    changeSet = this.filterChangeSet(changeSet);\n    // Assume server doesn't understand @ngrx/entity Update<T> structure;\n    // Extract the entity changes from the Update<T>[] and restore on the return from server\n    changeSet = this.flattenUpdates(changeSet);\n\n    let result$: Observable<ChangeSet> = this.http\n      .post<ChangeSet>(url, changeSet)\n      .pipe(\n        map(result => this.restoreUpdates(result)),\n        catchError(this.handleError({ method: 'POST', url, data: changeSet }))\n      );\n\n    if (this.timeout) {\n      result$ = result$.pipe(timeout(this.timeout));\n    }\n\n    if (this.saveDelay) {\n      result$ = result$.pipe(delay(this.saveDelay));\n    }\n\n    return result$;\n  }\n\n  // #region helpers\n  protected handleError(reqData: RequestData) {\n    return (err: any) => {\n      const error = new DataServiceError(err, reqData);\n      return throwError(error);\n    };\n  }\n\n  /**\n   * Filter changeSet to remove unwanted ChangeSetItems.\n   * This implementation excludes null and empty ChangeSetItems.\n   * @param changeSet ChangeSet with changes to filter\n   */\n  protected filterChangeSet(changeSet: ChangeSet): ChangeSet {\n    return excludeEmptyChangeSetItems(changeSet);\n  }\n\n  /**\n   * Convert the entities in update changes from @ngrx Update<T> structure to just T.\n   * Reverse of restoreUpdates().\n   */\n  protected flattenUpdates(changeSet: ChangeSet): ChangeSet {\n    let changes = changeSet.changes;\n    if (changes.length === 0) {\n      return changeSet;\n    }\n    let hasMutated = false;\n    changes = changes.map(item => {\n      if (item.op === updateOp && item.entities.length > 0) {\n        hasMutated = true;\n        return {\n          ...item,\n          entities: (item as ChangeSetUpdate).entities.map(u => u.changes)\n        };\n      } else {\n        return item;\n      }\n    }) as ChangeSetItem[];\n    return hasMutated ? { ...changeSet, changes } : changeSet;\n  }\n\n  /**\n   * Convert the flattened T entities in update changes back to @ngrx Update<T> structures.\n   * Reverse of flattenUpdates().\n   */\n  protected restoreUpdates(changeSet: ChangeSet): ChangeSet {\n    if (changeSet == null) {\n      // Nothing? Server probably responded with 204 - No Content because it made no changes to the inserted or updated entities\n      return changeSet;\n    }\n    let changes = changeSet.changes;\n    if (changes.length === 0) {\n      return changeSet;\n    }\n    let hasMutated = false;\n    changes = changes.map(item => {\n      if (item.op === updateOp) {\n        // These are entities, not Updates; convert back to Updates\n        hasMutated = true;\n        const selectId = this.getIdSelector(item.entityName);\n        return {\n          ...item,\n          entities: item.entities.map((u: any) => ({ id: selectId(u), changes: u }))\n        } as ChangeSetUpdate;\n      } else {\n        return item;\n      }\n    }) as ChangeSetItem[];\n    return hasMutated ? { ...changeSet, changes } : changeSet;\n  }\n\n  /**\n   * Get the id (primary key) selector function for an entity type\n   * @param entityName name of the entity type\n   */\n  protected getIdSelector(entityName: string) {\n    let idSelector = this.idSelectors[entityName];\n    if (!idSelector) {\n      idSelector = this.entityDefinitionService.getDefinition(entityName).selectId;\n      this.idSelectors[entityName] = idSelector;\n    }\n    return idSelector;\n  }\n  // #endregion helpers\n}\n","import { Injectable } from '@angular/core';\n\nimport { EntityCollectionDataService } from './interfaces';\nimport { DefaultDataServiceFactory } from './default-data.service';\n\n/**\n * Registry of EntityCollection data services that make REST-like CRUD calls\n * to entity collection endpoints.\n */\n@Injectable()\nexport class EntityDataService {\n  protected services: { [name: string]: EntityCollectionDataService<any> } = {};\n\n  // TODO:  Optionally inject specialized entity data services\n  // for those that aren't derived from BaseDataService.\n  constructor(protected defaultDataServiceFactory: DefaultDataServiceFactory) {}\n\n  /**\n   * Get (or create) a data service for entity type\n   * @param entityName - the name of the type\n   *\n   * Examples:\n   *   getService('Hero'); // data service for Heroes, untyped\n   *   getService<Hero>('Hero'); // data service for Heroes, typed as Hero\n   */\n  getService<T>(entityName: string): EntityCollectionDataService<T> {\n    entityName = entityName.trim();\n    let service = this.services[entityName];\n    if (!service) {\n      service = this.defaultDataServiceFactory.create(entityName);\n      this.services[entityName] = service;\n    }\n    return service;\n  }\n\n  /**\n   * Register an EntityCollectionDataService for an entity type\n   * @param entityName - the name of the entity type\n   * @param service - data service for that entity type\n   *\n   * Examples:\n   *   registerService('Hero', myHeroDataService);\n   *   registerService('Villain', myVillainDataService);\n   */\n  registerService<T>(entityName: string, service: EntityCollectionDataService<T>) {\n    this.services[entityName.trim()] = service;\n  }\n\n  /**\n   * Register a batch of data services.\n   * @param services - data services to merge into existing services\n   *\n   * Examples:\n   *   registerServices({\n   *     Hero: myHeroDataService,\n   *     Villain: myVillainDataService\n   *   });\n   */\n  registerServices(services: { [name: string]: EntityCollectionDataService<any> }) {\n    this.services = { ...this.services, ...services };\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\n\nimport { Observable, of } from 'rxjs';\n\nimport { DataServiceError, EntityActionDataServiceError } from './data-service-error';\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityActionFactory } from '../actions/entity-action-factory';\nimport { EntityOp, makeErrorOp, makeSuccessOp } from '../actions/entity-op';\nimport { Logger } from '../utils/interfaces';\n\n/**\n * Handling of responses from persistence operation\n */\nexport abstract class PersistenceResultHandler {\n  /** Handle successful result of persistence operation for an action */\n  abstract handleSuccess(originalAction: EntityAction): (data: any) => Action;\n\n  /** Handle error result of persistence operation for an action */\n  abstract handleError(originalAction: EntityAction): (error: DataServiceError | Error) => EntityAction<EntityActionDataServiceError>;\n}\n\n/**\n * Default handling of responses from persistence operation,\n * specifically an EntityDataService\n */\n@Injectable()\nexport class DefaultPersistenceResultHandler implements PersistenceResultHandler {\n  constructor(private logger: Logger, private entityActionFactory: EntityActionFactory) {}\n\n  /** Handle successful result of persistence operation on an EntityAction */\n  handleSuccess(originalAction: EntityAction): (data: any) => Action {\n    const successOp = makeSuccessOp(originalAction.payload.entityOp);\n    return (data: any) => this.entityActionFactory.createFromAction(originalAction, { entityOp: successOp, data });\n  }\n\n  /** Handle error result of persistence operation on an EntityAction */\n  handleError(originalAction: EntityAction): (error: DataServiceError | Error) => EntityAction<EntityActionDataServiceError> {\n    const errorOp = makeErrorOp(originalAction.payload.entityOp);\n\n    return (err: DataServiceError | Error) => {\n      const error = err instanceof DataServiceError ? err : new DataServiceError(err, null);\n      const errorData: EntityActionDataServiceError = { error, originalAction };\n      this.logger.error(errorData);\n      const action = this.entityActionFactory.createFromAction<EntityActionDataServiceError>(originalAction, {\n        entityOp: errorOp,\n        data: errorData\n      });\n      return action;\n    };\n  }\n}\n","import { Injectable } from '@angular/core';\n\n/**\n * Generates a string id beginning 'CRID',\n * followed by a monotonically increasing integer for use as a correlation id.\n * As they are produced locally by a singleton service,\n * these ids are guaranteed to be unique only\n * for the duration of a single client browser instance.\n * Ngrx entity dispatcher query and save methods call this service to generate default correlation ids.\n * Do NOT use for entity keys.\n */\n@Injectable()\nexport class CorrelationIdGenerator {\n  /** Seed for the ids */\n  protected seed = 0;\n  /** Prefix of the id, 'CRID; */\n  protected prefix = 'CRID';\n  /** Return the next correlation id */\n  next() {\n    this.seed += 1;\n    return this.prefix + this.seed;\n  }\n}\n","import { Injectable } from '@angular/core';\n/**\n * Default options for EntityDispatcher behavior\n * such as whether `add()` is optimistic or pessimistic by default.\n * An optimistic save modifies the collection immediately and before saving to the server.\n * A pessimistic save modifies the collection after the server confirms the save was successful.\n * This class initializes the defaults to the safest values.\n * Provide an alternative to change the defaults for all entity collections.\n */\n@Injectable()\nexport class EntityDispatcherDefaultOptions {\n  /** True if added entities are saved optimistically; false if saved pessimistically. */\n  optimisticAdd = false;\n  /** True if deleted entities are saved optimistically; false if saved pessimistically. */\n  optimisticDelete = true;\n  /** True if updated entities are saved optimistically; false if saved pessimistically. */\n  optimisticUpdate = false;\n  /** True if upsert entities are saved optimistically; false if saved pessimistically. */\n  optimisticUpsert = false;\n  /** True if entities in a cache saveEntities request are saved optimistically; false if saved pessimistically. */\n  optimisticSaveEntities = false;\n}\n","import { Action, Store } from '@ngrx/store';\n\nimport { EntityAction, EntityActionOptions } from '../actions/entity-action';\nimport { EntityActionGuard } from '../actions/entity-action-guard';\nimport { EntityCommands } from './entity-commands';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityOp } from '../actions/entity-op';\nimport { IdSelector, Update } from '../utils/ngrx-entity-models';\n\n/**\n * Dispatches EntityCollection actions to their reducers and effects.\n * The substance of the interface is in EntityCommands.\n */\nexport interface EntityDispatcher<T> extends EntityCommands<T> {\n  /** Name of the entity type */\n  readonly entityName: string;\n\n  /**\n   * Utility class with methods to validate EntityAction payloads.\n   */\n  readonly guard: EntityActionGuard;\n\n  /** Returns the primary key (id) of this entity */\n  readonly selectId: IdSelector<T>;\n\n  /** Returns the store, scoped to the EntityCache */\n  readonly store: Store<EntityCache>;\n\n  /**\n   * Create an {EntityAction} for this entity type.\n   * @param op {EntityOp} the entity operation\n   * @param [data] the action data\n   * @param [options] additional options\n   * @returns the EntityAction\n   */\n  createEntityAction<P = any>(op: EntityOp, data?: P, options?: EntityActionOptions): EntityAction<P>;\n\n  /**\n   * Create an {EntityAction} for this entity type and\n   * dispatch it immediately to the store.\n   * @param op {EntityOp} the entity operation\n   * @param [data] the action data\n   * @param [options] additional options\n   * @returns the dispatched EntityAction\n   */\n  createAndDispatch<P = any>(op: EntityOp, data?: P, options?: EntityActionOptions): EntityAction<P>;\n\n  /**\n   * Dispatch an Action to the store.\n   * @param action the Action\n   * @returns the dispatched Action\n   */\n  dispatch(action: Action): Action;\n\n  /**\n   * Convert an entity (or partial entity) into the `Update<T>` object\n   * `update...` and `upsert...` methods take `Update<T>` args\n   */\n  toUpdate(entity: Partial<T>): Update<T>;\n}\n\n/**\n * Persistence operation canceled\n */\nexport class PersistanceCanceled {\n  constructor(public readonly message?: string) {\n    this.message = message || 'Canceled by user';\n  }\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Action, createSelector, ScannedActionsSubject, select, Store } from '@ngrx/store';\n\nimport { Observable, of, Subscription, throwError } from 'rxjs';\nimport { filter, map, mergeMap, shareReplay, take } from 'rxjs/operators';\n\nimport { CorrelationIdGenerator } from '../utils/correlation-id-generator';\nimport { EntityAction, EntityActionOptions } from '../actions/entity-action';\nimport { EntityActionFactory } from '../actions/entity-action-factory';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityDispatcherDefaultOptions } from './entity-dispatcher-default-options';\n\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { PersistanceCanceled } from './entity-dispatcher';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\nimport { ChangeSet, ChangeSetItem } from '../actions/entity-cache-change-set';\nimport {\n  ClearCollections,\n  EntityCacheAction,\n  EntityCacheQuerySet,\n  LoadCollections,\n  MergeQuerySet,\n  SetEntityCache,\n  SaveEntities,\n  SaveEntitiesCancel,\n  SaveEntitiesError,\n  SaveEntitiesSuccess\n} from '../actions/entity-cache-action';\n\n/**\n * Dispatches Entity Cache actions to the EntityCache reducer\n */\n@Injectable()\nexport class EntityCacheDispatcher {\n  /**\n   * Actions scanned by the store after it processed them with reducers.\n   * A replay observable of the most recent action reduced by the store.\n   */\n  reducedActions$: Observable<Action>;\n  private raSubscription: Subscription;\n\n  constructor(\n    /** Generates correlation ids for query and save methods */\n    private correlationIdGenerator: CorrelationIdGenerator,\n    /**\n     * Dispatcher options configure dispatcher behavior such as\n     * whether add is optimistic or pessimistic by default.\n     */\n    private defaultDispatcherOptions: EntityDispatcherDefaultOptions,\n    /** Actions scanned by the store after it processed them with reducers. */\n    @Inject(ScannedActionsSubject) scannedActions$: Observable<Action>,\n    /** The store, scoped to the EntityCache */\n    private store: Store<EntityCache>\n  ) {\n    // Replay because sometimes in tests will fake data service with synchronous observable\n    // which makes subscriber miss the dispatched actions.\n    // Of course that's a testing mistake. But easy to forget, leading to painful debugging.\n    this.reducedActions$ = scannedActions$.pipe(shareReplay(1));\n    // Start listening so late subscriber won't miss the most recent action.\n    this.raSubscription = this.reducedActions$.subscribe();\n  }\n\n  /**\n   * Dispatch an Action to the store.\n   * @param action the Action\n   * @returns the dispatched Action\n   */\n  dispatch(action: Action): Action {\n    this.store.dispatch(action);\n    return action;\n  }\n\n  /**\n   * Dispatch action to cancel the saveEntities request with matching correlation id.\n   * @param correlationId The correlation id for the corresponding action\n   * @param [reason] explains why canceled and by whom.\n   * @param [entityNames] array of entity names so can turn off loading flag for their collections.\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  cancelSaveEntities(correlationId: any, reason?: string, entityNames?: string[], tag?: string): void {\n    if (!correlationId) {\n      throw new Error('Missing correlationId');\n    }\n    const action = new SaveEntitiesCancel(correlationId, reason, entityNames, tag);\n    this.dispatch(action);\n  }\n\n  /** Clear the named entity collections in cache\n   * @param [collections] Array of names of the collections to clear.\n   * If empty array, does nothing. If null/undefined/no array, clear all collections.\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  clearCollections(collections?: string[], tag?: string) {\n    this.dispatch(new ClearCollections(collections, tag));\n  }\n\n  /**\n   * Load multiple entity collections at the same time.\n   * before any selectors$ observables emit.\n   * @param collections The collections to load, typically the result of a query.\n   * @param [tag] tag to identify the operation from the app perspective.\n   * in the form of a map of entity collections.\n   */\n  loadCollections(collections: EntityCacheQuerySet, tag?: string) {\n    this.dispatch(new LoadCollections(collections, tag));\n  }\n\n  /**\n   * Merges entities from a query result\n   * that returned entities from multiple collections.\n   * Corresponding entity cache reducer should add and update all collections\n   * at the same time, before any selectors$ observables emit.\n   * @param querySet The result of the query in the form of a map of entity collections.\n   * These are the entity data to merge into the respective collections.\n   * @param mergeStrategy How to merge a queried entity when it is already in the collection.\n   * The default is MergeStrategy.PreserveChanges\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  mergeQuerySet(querySet: EntityCacheQuerySet, mergeStrategy?: MergeStrategy, tag?: string) {\n    this.dispatch(new MergeQuerySet(querySet, mergeStrategy, tag));\n  }\n\n  /**\n   * Create entity cache action for replacing the entire entity cache.\n   * Dangerous because brute force but useful as when re-hydrating an EntityCache\n   * from local browser storage when the application launches.\n   * @param cache New state of the entity cache\n   * @param [tag] tag to identify the operation from the app perspective.\n   */\n  setEntityCache(cache: EntityCache, tag?: string) {\n    this.dispatch(new SetEntityCache(cache, tag));\n  }\n\n  /**\n   * Dispatch action to save multiple entity changes to remote storage.\n   * Relies on an Ngrx Effect such as EntityEffects.saveEntities$.\n   * Important: only call if your server supports the SaveEntities protocol\n   * through your EntityDataService.saveEntities method.\n   * @param changes Either the entities to save, as an array of {ChangeSetItem}, or\n   * a ChangeSet that holds such changes.\n   * @param url The server url which receives the save request\n   * @param [options] options such as tag, correlationId, isOptimistic, and mergeStrategy.\n   * These values are defaulted if not supplied.\n   * @returns A terminating Observable<ChangeSet> with data returned from the server\n   * after server reports successful save OR the save error.\n   * TODO: should return the matching entities from cache rather than the raw server data.\n   */\n  saveEntities(changes: ChangeSetItem[] | ChangeSet, url: string, options?: EntityActionOptions): Observable<ChangeSet> {\n    const changeSet = Array.isArray(changes) ? { changes } : changes;\n    options = options || {};\n    const correlationId = options.correlationId == null ? this.correlationIdGenerator.next() : options.correlationId;\n    const isOptimistic =\n      options.isOptimistic == null ? this.defaultDispatcherOptions.optimisticSaveEntities || false : options.isOptimistic === true;\n    const tag = options.tag || 'Save Entities';\n    options = { ...options, correlationId, isOptimistic, tag };\n    const action = new SaveEntities(changeSet, url, options);\n    this.dispatch(action);\n    return this.getSaveEntitiesResponseData$(options.correlationId).pipe(shareReplay(1));\n  }\n\n  /**\n   * Return Observable of data from the server-success SaveEntities action with\n   * the given Correlation Id, after that action was processed by the ngrx store.\n   * or else put the server error on the Observable error channel.\n   * @param crid The correlationId for both the save and response actions.\n   */\n  private getSaveEntitiesResponseData$(crid: any): Observable<ChangeSet> {\n    /**\n     * reducedActions$ must be replay observable of the most recent action reduced by the store.\n     * because the response action might have been dispatched to the store\n     * before caller had a chance to subscribe.\n     */\n    return this.reducedActions$.pipe(\n      filter(\n        (act: Action) =>\n          act.type === EntityCacheAction.SAVE_ENTITIES_SUCCESS ||\n          act.type === EntityCacheAction.SAVE_ENTITIES_ERROR ||\n          act.type === EntityCacheAction.SAVE_ENTITIES_CANCEL\n      ),\n      filter((act: { type: string; payload: any }) => crid === (act as any).payload.correlationId),\n      take(1),\n      mergeMap(act => {\n        return act.type === EntityCacheAction.SAVE_ENTITIES_CANCEL\n          ? throwError(new PersistanceCanceled((act as SaveEntitiesCancel).payload.reason))\n          : act.type === EntityCacheAction.SAVE_ENTITIES_SUCCESS\n            ? of((act as SaveEntitiesSuccess).payload.changeSet)\n            : throwError((act as SaveEntitiesError).payload);\n      })\n    );\n  }\n}\n","import { Action, createSelector, select, Store } from '@ngrx/store';\n\nimport { Observable, of, throwError } from 'rxjs';\nimport { filter, map, mergeMap, shareReplay, withLatestFrom, take } from 'rxjs/operators';\n\nimport { CorrelationIdGenerator } from '../utils/correlation-id-generator';\nimport { defaultSelectId, toUpdateFactory } from '../utils/utilities';\nimport { EntityAction, EntityActionOptions } from '../actions/entity-action';\nimport { EntityActionFactory } from '../actions/entity-action-factory';\nimport { EntityActionGuard } from '../actions/entity-action-guard';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityCacheSelector } from '../selectors/entity-cache-selector';\nimport { EntityCollection } from '../reducers/entity-collection';\nimport { EntityCommands } from './entity-commands';\nimport { EntityDispatcher, PersistanceCanceled } from './entity-dispatcher';\nimport { EntityDispatcherDefaultOptions } from './entity-dispatcher-default-options';\nimport { EntityOp, OP_ERROR, OP_SUCCESS } from '../actions/entity-op';\nimport { IdSelector, Update } from '../utils/ngrx-entity-models';\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { QueryParams } from '../dataservices/interfaces';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\n/**\n * Dispatches EntityCollection actions to their reducers and effects (default implementation).\n * All save commands rely on an Ngrx Effect such as `EntityEffects.persist$`.\n */\nexport class EntityDispatcherBase<T> implements EntityDispatcher<T> {\n  /** Utility class with methods to validate EntityAction payloads.*/\n  guard: EntityActionGuard;\n\n  private entityCollection$: Observable<EntityCollection<T>>;\n\n  /**\n   * Convert an entity (or partial entity) into the `Update<T>` object\n   * `update...` and `upsert...` methods take `Update<T>` args\n   */\n  toUpdate: (entity: Partial<T>) => Update<T>;\n\n  constructor(\n    /** Name of the entity type for which entities are dispatched */\n    public entityName: string,\n    /** Creates an {EntityAction} */\n    public entityActionFactory: EntityActionFactory,\n    /** The store, scoped to the EntityCache */\n    public store: Store<EntityCache>,\n    /** Returns the primary key (id) of this entity */\n    public selectId: IdSelector<T> = defaultSelectId,\n    /**\n     * Dispatcher options configure dispatcher behavior such as\n     * whether add is optimistic or pessimistic by default.\n     */\n    private defaultDispatcherOptions: EntityDispatcherDefaultOptions,\n    /** Actions scanned by the store after it processed them with reducers. */\n    private reducedActions$: Observable<Action>,\n    /** Store selector for the EntityCache */\n    entityCacheSelector: EntityCacheSelector,\n    /** Generates correlation ids for query and save methods */\n    private correlationIdGenerator: CorrelationIdGenerator\n  ) {\n    this.guard = new EntityActionGuard(entityName, selectId);\n    this.toUpdate = toUpdateFactory<T>(selectId);\n\n    const collectionSelector = createSelector(\n      entityCacheSelector,\n      cache => cache[entityName] as EntityCollection<T>\n    );\n    this.entityCollection$ = store.select(collectionSelector);\n  }\n\n  /**\n   * Create an {EntityAction} for this entity type.\n   * @param entityOp {EntityOp} the entity operation\n   * @param [data] the action data\n   * @param [options] additional options\n   * @returns the EntityAction\n   */\n  createEntityAction<P = any>(\n    entityOp: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P> {\n    return this.entityActionFactory.create({\n      entityName: this.entityName,\n      entityOp,\n      data,\n      ...options\n    });\n  }\n\n  /**\n   * Create an {EntityAction} for this entity type and\n   * dispatch it immediately to the store.\n   * @param op {EntityOp} the entity operation\n   * @param [data] the action data\n   * @param [options] additional options\n   * @returns the dispatched EntityAction\n   */\n  createAndDispatch<P = any>(\n    op: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P> {\n    const action = this.createEntityAction(op, data, options);\n    this.dispatch(action);\n    return action;\n  }\n\n  /**\n   * Dispatch an Action to the store.\n   * @param action the Action\n   * @returns the dispatched Action\n   */\n  dispatch(action: Action): Action {\n    this.store.dispatch(action);\n    return action;\n  }\n\n  // #region Query and save operations\n\n  /**\n   * Dispatch action to save a new entity to remote storage.\n   * @param entity entity to add, which may omit its key if pessimistic and the server creates the key;\n   * must have a key if optimistic save.\n   * @returns A terminating Observable of the entity\n   * after server reports successful save or the save error.\n   */\n  add(entity: T, options?: EntityActionOptions): Observable<T> {\n    options = this.setSaveEntityActionOptions(options, this.defaultDispatcherOptions.optimisticAdd);\n    const action = this.createEntityAction(EntityOp.SAVE_ADD_ONE, entity, options);\n    if (options.isOptimistic) {\n      this.guard.mustBeEntity(action);\n    }\n    this.dispatch(action);\n    return this.getResponseData$<T>(options.correlationId).pipe(\n      // Use the returned entity data's id to get the entity from the collection\n      // as it might be different from the entity returned from the server.\n      withLatestFrom(this.entityCollection$),\n      map(([e, collection]) => collection.entities[this.selectId(e)]),\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Dispatch action to cancel the persistence operation (query or save).\n   * Will cause save observable to error with a PersistenceCancel error.\n   * Caller is responsible for undoing changes in cache from pending optimistic save\n   * @param correlationId The correlation id for the corresponding EntityAction\n   * @param [reason] explains why canceled and by whom.\n   */\n  cancel(correlationId: any, reason?: string, options?: EntityActionOptions): void {\n    if (!correlationId) {\n      throw new Error('Missing correlationId');\n    }\n    this.createAndDispatch(EntityOp.CANCEL_PERSIST, reason, { correlationId });\n  }\n\n  /**\n   * Dispatch action to delete entity from remote storage by key.\n   * @param key The primary key of the entity to remove\n   * @returns A terminating Observable of the deleted key\n   * after server reports successful save or the save error.\n   */\n  delete(entity: T, options?: EntityActionOptions): Observable<number | string>;\n\n  /**\n   * Dispatch action to delete entity from remote storage by key.\n   * @param key The entity to delete\n   * @returns A terminating Observable of the deleted key\n   * after server reports successful save or the save error.\n   */\n  delete(key: number | string, options?: EntityActionOptions): Observable<number | string>;\n  delete(arg: number | string | T, options?: EntityActionOptions): Observable<number | string> {\n    options = this.setSaveEntityActionOptions(\n      options,\n      this.defaultDispatcherOptions.optimisticDelete\n    );\n    const key = this.getKey(arg);\n    const action = this.createEntityAction(EntityOp.SAVE_DELETE_ONE, key, options);\n    this.guard.mustBeKey(action);\n    this.dispatch(action);\n    return this.getResponseData$<number | string>(options.correlationId).pipe(\n      map(() => key),\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Dispatch action to query remote storage for all entities and\n   * merge the queried entities into the cached collection.\n   * @returns A terminating Observable of the queried entities that are in the collection\n   * after server reports success query or the query error.\n   * @see load()\n   */\n  getAll(options?: EntityActionOptions): Observable<T[]> {\n    options = this.setQueryEntityActionOptions(options);\n    const action = this.createEntityAction(EntityOp.QUERY_ALL, null, options);\n    this.dispatch(action);\n    return this.getResponseData$<T[]>(options.correlationId).pipe(\n      // Use the returned entity ids to get the entities from the collection\n      // as they might be different from the entities returned from the server\n      // because of unsaved changes (deletes or updates).\n      withLatestFrom(this.entityCollection$),\n      map(([entities, collection]) =>\n        entities.reduce(\n          (acc, e) => {\n            const entity = collection.entities[this.selectId(e)];\n            if (entity) {\n              acc.push(entity); // only return an entity found in the collection\n            }\n            return acc;\n          },\n          [] as T[]\n        )\n      ),\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Dispatch action to query remote storage for the entity with this primary key.\n   * If the server returns an entity,\n   * merge it into the cached collection.\n   * @returns A terminating Observable of the collection\n   * after server reports successful query or the query error.\n   */\n  getByKey(key: any, options?: EntityActionOptions): Observable<T> {\n    options = this.setQueryEntityActionOptions(options);\n    const action = this.createEntityAction(EntityOp.QUERY_BY_KEY, key, options);\n    this.dispatch(action);\n    return this.getResponseData$<T>(options.correlationId).pipe(\n      // Use the returned entity data's id to get the entity from the collection\n      // as it might be different from the entity returned from the server.\n      withLatestFrom(this.entityCollection$),\n      map(([entity, collection]) => collection.entities[this.selectId(entity)]),\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Dispatch action to query remote storage for the entities that satisfy a query expressed\n   * with either a query parameter map or an HTTP URL query string,\n   * and merge the results into the cached collection.\n   * @params queryParams the query in a form understood by the server\n   * @returns A terminating Observable of the queried entities\n   * after server reports successful query or the query error.\n   */\n  getWithQuery(queryParams: QueryParams | string, options?: EntityActionOptions): Observable<T[]> {\n    options = this.setQueryEntityActionOptions(options);\n    const action = this.createEntityAction(EntityOp.QUERY_MANY, queryParams, options);\n    this.dispatch(action);\n    return this.getResponseData$<T[]>(options.correlationId).pipe(\n      // Use the returned entity ids to get the entities from the collection\n      // as they might be different from the entities returned from the server\n      // because of unsaved changes (deletes or updates).\n      withLatestFrom(this.entityCollection$),\n      map(([entities, collection]) =>\n        entities.reduce(\n          (acc, e) => {\n            const entity = collection.entities[this.selectId(e)];\n            if (entity) {\n              acc.push(entity); // only return an entity found in the collection\n            }\n            return acc;\n          },\n          [] as T[]\n        )\n      ),\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Dispatch action to query remote storage for all entities and\n   * completely replace the cached collection with the queried entities.\n   * @returns A terminating Observable of the entities in the collection\n   * after server reports successful query or the query error.\n   * @see getAll\n   */\n  load(options?: EntityActionOptions): Observable<T[]> {\n    options = this.setQueryEntityActionOptions(options);\n    const action = this.createEntityAction(EntityOp.QUERY_LOAD, null, options);\n    this.dispatch(action);\n    return this.getResponseData$<T[]>(options.correlationId).pipe(shareReplay(1));\n  }\n\n  /**\n   * Dispatch action to save the updated entity (or partial entity) in remote storage.\n   * The update entity may be partial (but must have its key)\n   * in which case it patches the existing entity.\n   * @param entity update entity, which might be a partial of T but must at least have its key.\n   * @returns A terminating Observable of the updated entity\n   * after server reports successful save or the save error.\n   */\n  update(entity: Partial<T>, options?: EntityActionOptions): Observable<T> {\n    // update entity might be a partial of T but must at least have its key.\n    // pass the Update<T> structure as the payload\n    const update: Update<T> = this.toUpdate(entity);\n    options = this.setSaveEntityActionOptions(\n      options,\n      this.defaultDispatcherOptions.optimisticUpdate\n    );\n    const action = this.createEntityAction(EntityOp.SAVE_UPDATE_ONE, update, options);\n    if (options.isOptimistic) {\n      this.guard.mustBeEntity(action);\n    }\n    this.dispatch(action);\n    return this.getResponseData$<UpdateResponseData<T>>(options.correlationId).pipe(\n      // Use the update entity data id to get the entity from the collection\n      // as might be different from the entity returned from the server\n      // because the id changed or there are unsaved changes.\n      map(updateData => updateData.changes),\n      withLatestFrom(this.entityCollection$),\n      map(([e, collection]) => collection.entities[this.selectId(e)]),\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Dispatch action to save a new or existing entity to remote storage.\n   * Only dispatch this action if your server supports upsert.\n   * @param entity entity to add, which may omit its key if pessimistic and the server creates the key;\n   * must have a key if optimistic save.\n   * @returns A terminating Observable of the entity\n   * after server reports successful save or the save error.\n   */\n  upsert(entity: T, options?: EntityActionOptions): Observable<T> {\n    options = this.setSaveEntityActionOptions(\n      options,\n      this.defaultDispatcherOptions.optimisticUpsert\n    );\n    const action = this.createEntityAction(EntityOp.SAVE_UPSERT_ONE, entity, options);\n    if (options.isOptimistic) {\n      this.guard.mustBeEntity(action);\n    }\n    this.dispatch(action);\n    return this.getResponseData$<T>(options.correlationId).pipe(\n      // Use the returned entity data's id to get the entity from the collection\n      // as it might be different from the entity returned from the server.\n      withLatestFrom(this.entityCollection$),\n      map(([e, collection]) => collection.entities[this.selectId(e)]),\n      shareReplay(1)\n    );\n  }\n  // #endregion Query and save operations\n\n  // #region Cache-only operations that do not update remote storage\n\n  // Unguarded for performance.\n  // EntityCollectionReducer<T> runs a guard (which throws)\n  // Developer should understand cache-only methods well enough\n  // to call them with the proper entities.\n  // May reconsider and add guards in future.\n\n  /**\n   * Replace all entities in the cached collection.\n   * Does not save to remote storage.\n   */\n  addAllToCache(entities: T[], options?: EntityActionOptions): void {\n    this.createAndDispatch(EntityOp.ADD_ALL, entities, options);\n  }\n\n  /**\n   * Add a new entity directly to the cache.\n   * Does not save to remote storage.\n   * Ignored if an entity with the same primary key is already in cache.\n   */\n  addOneToCache(entity: T, options?: EntityActionOptions): void {\n    this.createAndDispatch(EntityOp.ADD_ONE, entity, options);\n  }\n\n  /**\n   * Add multiple new entities directly to the cache.\n   * Does not save to remote storage.\n   * Entities with primary keys already in cache are ignored.\n   */\n  addManyToCache(entities: T[], options?: EntityActionOptions): void {\n    this.createAndDispatch(EntityOp.ADD_MANY, entities, options);\n  }\n\n  /** Clear the cached entity collection */\n  clearCache(options?: EntityActionOptions): void {\n    this.createAndDispatch(EntityOp.REMOVE_ALL, undefined, options);\n  }\n\n  /**\n   * Remove an entity directly from the cache.\n   * Does not delete that entity from remote storage.\n   * @param entity The entity to remove\n   */\n  removeOneFromCache(entity: T, options?: EntityActionOptions): void;\n\n  /**\n   * Remove an entity directly from the cache.\n   * Does not delete that entity from remote storage.\n   * @param key The primary key of the entity to remove\n   */\n  removeOneFromCache(key: number | string, options?: EntityActionOptions): void;\n  removeOneFromCache(arg: (number | string) | T, options?: EntityActionOptions): void {\n    this.createAndDispatch(EntityOp.REMOVE_ONE, this.getKey(arg), options);\n  }\n\n  /**\n   * Remove multiple entities directly from the cache.\n   * Does not delete these entities from remote storage.\n   * @param entity The entities to remove\n   */\n  removeManyFromCache(entities: T[], options?: EntityActionOptions): void;\n\n  /**\n   * Remove multiple entities directly from the cache.\n   * Does not delete these entities from remote storage.\n   * @param keys The primary keys of the entities to remove\n   */\n  removeManyFromCache(keys: (number | string)[], options?: EntityActionOptions): void;\n  removeManyFromCache(args: (number | string)[] | T[], options?: EntityActionOptions): void {\n    if (!args || args.length === 0) {\n      return;\n    }\n    const keys =\n      typeof args[0] === 'object'\n        ? // if array[0] is a key, assume they're all keys\n          (<T[]>args).map(arg => this.getKey(arg))\n        : args;\n    this.createAndDispatch(EntityOp.REMOVE_MANY, keys, options);\n  }\n\n  /**\n   * Update a cached entity directly.\n   * Does not update that entity in remote storage.\n   * Ignored if an entity with matching primary key is not in cache.\n   * The update entity may be partial (but must have its key)\n   * in which case it patches the existing entity.\n   */\n  updateOneInCache(entity: Partial<T>, options?: EntityActionOptions): void {\n    // update entity might be a partial of T but must at least have its key.\n    // pass the Update<T> structure as the payload\n    const update: Update<T> = this.toUpdate(entity);\n    this.createAndDispatch(EntityOp.UPDATE_ONE, update, options);\n  }\n\n  /**\n   * Update multiple cached entities directly.\n   * Does not update these entities in remote storage.\n   * Entities whose primary keys are not in cache are ignored.\n   * Update entities may be partial but must at least have their keys.\n   * such partial entities patch their cached counterparts.\n   */\n  updateManyInCache(entities: Partial<T>[], options?: EntityActionOptions): void {\n    if (!entities || entities.length === 0) {\n      return;\n    }\n    const updates: Update<T>[] = entities.map(entity => this.toUpdate(entity));\n    this.createAndDispatch(EntityOp.UPDATE_MANY, updates, options);\n  }\n\n  /**\n   * Add or update a new entity directly to the cache.\n   * Does not save to remote storage.\n   * Upsert entity might be a partial of T but must at least have its key.\n   * Pass the Update<T> structure as the payload\n   */\n  upsertOneInCache(entity: Partial<T>, options?: EntityActionOptions): void {\n    this.createAndDispatch(EntityOp.UPSERT_ONE, entity, options);\n  }\n\n  /**\n   * Add or update multiple cached entities directly.\n   * Does not save to remote storage.\n   */\n  upsertManyInCache(entities: Partial<T>[], options?: EntityActionOptions): void {\n    if (!entities || entities.length === 0) {\n      return;\n    }\n    this.createAndDispatch(EntityOp.UPSERT_MANY, entities, options);\n  }\n\n  /**\n   * Set the pattern that the collection's filter applies\n   * when using the `filteredEntities` selector.\n   */\n  setFilter(pattern: any): void {\n    this.createAndDispatch(EntityOp.SET_FILTER, pattern);\n  }\n\n  /** Set the loaded flag */\n  setLoaded(isLoaded: boolean): void {\n    this.createAndDispatch(EntityOp.SET_LOADED, !!isLoaded);\n  }\n\n  /** Set the loading flag */\n  setLoading(isLoading: boolean): void {\n    this.createAndDispatch(EntityOp.SET_LOADING, !!isLoading);\n  }\n  // #endregion Cache-only operations that do not update remote storage\n\n  // #region private helpers\n\n  /** Get key from entity (unless arg is already a key) */\n  private getKey(arg: number | string | T) {\n    return typeof arg === 'object' ? this.selectId(arg) : arg;\n  }\n\n  /**\n   * Return Observable of data from the server-success EntityAction with\n   * the given Correlation Id, after that action was processed by the ngrx store.\n   * or else put the server error on the Observable error channel.\n   * @param crid The correlationId for both the save and response actions.\n   */\n  private getResponseData$<D = any>(crid: any): Observable<D> {\n    /**\n     * reducedActions$ must be replay observable of the most recent action reduced by the store.\n     * because the response action might have been dispatched to the store\n     * before caller had a chance to subscribe.\n     */\n    return this.reducedActions$.pipe(\n      filter((act: any) => !!act.payload),\n      filter((act: EntityAction) => {\n        const { correlationId, entityName, entityOp } = act.payload;\n        return (\n          entityName === this.entityName &&\n          correlationId === crid &&\n          (entityOp.endsWith(OP_SUCCESS) ||\n            entityOp.endsWith(OP_ERROR) ||\n            entityOp === EntityOp.CANCEL_PERSIST)\n        );\n      }),\n      take(1),\n      mergeMap(act => {\n        const { entityOp } = act.payload;\n        return entityOp === EntityOp.CANCEL_PERSIST\n          ? throwError(new PersistanceCanceled(act.payload.data))\n          : entityOp.endsWith(OP_SUCCESS)\n            ? of(act.payload.data as D)\n            : throwError(act.payload.data.error);\n      })\n    );\n  }\n\n  private setQueryEntityActionOptions(options: EntityActionOptions): EntityActionOptions {\n    options = options || {};\n    const correlationId =\n      options.correlationId == null ? this.correlationIdGenerator.next() : options.correlationId;\n    return { ...options, correlationId };\n  }\n\n  private setSaveEntityActionOptions(\n    options: EntityActionOptions,\n    defaultOptimism: boolean\n  ): EntityActionOptions {\n    options = options || {};\n    const correlationId =\n      options.correlationId == null ? this.correlationIdGenerator.next() : options.correlationId;\n    const isOptimistic =\n      options.isOptimistic == null ? defaultOptimism || false : options.isOptimistic === true;\n    return { ...options, correlationId, isOptimistic };\n  }\n  // #endregion private helpers\n}\n","import { InjectionToken } from '@angular/core';\nimport { Action, ActionReducer, MetaReducer } from '@ngrx/store';\nimport { EntityCache } from './entity-cache';\n\nexport const ENTITY_CACHE_NAME = 'entityCache';\nexport const ENTITY_CACHE_NAME_TOKEN = new InjectionToken<string>('ngrx-data/entity-cache-name');\n\nexport const ENTITY_CACHE_META_REDUCERS = new InjectionToken<MetaReducer<any, any>[]>('ngrx-data/entity-cache-meta-reducers');\nexport const ENTITY_COLLECTION_META_REDUCERS = new InjectionToken<MetaReducer<any, any>[]>('ngrx-data/entity-collection-meta-reducers');\n\nexport const INITIAL_ENTITY_CACHE_STATE = new InjectionToken<EntityCache | (() => EntityCache)>('ngrx-data/initial-entity-cache-state');\n","import {\n  Inject,\n  Injectable,\n  InjectionToken,\n  Optional,\n  FactoryProvider\n} from '@angular/core';\nimport {\n  createFeatureSelector,\n  createSelector,\n  MemoizedSelector\n} from '@ngrx/store';\nimport { EntityCache } from '../reducers/entity-cache';\nimport {\n  ENTITY_CACHE_NAME,\n  ENTITY_CACHE_NAME_TOKEN\n} from '../reducers/constants';\n\nexport const ENTITY_CACHE_SELECTOR_TOKEN = new InjectionToken<\n  MemoizedSelector<Object, EntityCache>\n>('ngrx-data/entity-cache-selector');\n\nexport const entityCacheSelectorProvider: FactoryProvider = {\n  provide: ENTITY_CACHE_SELECTOR_TOKEN,\n  useFactory: createEntityCacheSelector,\n  deps: [[new Optional(), ENTITY_CACHE_NAME_TOKEN]]\n};\n\nexport type EntityCacheSelector = MemoizedSelector<Object, EntityCache>;\n\nexport function createEntityCacheSelector(\n  entityCacheName?: string\n): MemoizedSelector<Object, EntityCache> {\n  entityCacheName = entityCacheName || ENTITY_CACHE_NAME;\n  return createFeatureSelector<EntityCache>(entityCacheName);\n}\n","import { Inject, Injectable, OnDestroy } from '@angular/core';\nimport { Action, Store, ScannedActionsSubject } from '@ngrx/store';\nimport { Observable, Subscription } from 'rxjs';\nimport { shareReplay } from 'rxjs/operators';\n\nimport { CorrelationIdGenerator } from '../utils/correlation-id-generator';\nimport { EntityDispatcherDefaultOptions } from './entity-dispatcher-default-options';\nimport { defaultSelectId, toUpdateFactory } from '../utils/utilities';\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityActionFactory } from '../actions/entity-action-factory';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityCacheSelector, ENTITY_CACHE_SELECTOR_TOKEN, createEntityCacheSelector } from '../selectors/entity-cache-selector';\nimport { EntityDispatcher } from './entity-dispatcher';\nimport { EntityDispatcherBase } from './entity-dispatcher-base';\nimport { EntityOp } from '../actions/entity-op';\nimport { IdSelector, Update } from '../utils/ngrx-entity-models';\nimport { QueryParams } from '../dataservices/interfaces';\n\n/** Creates EntityDispatchers for entity collections */\n@Injectable()\nexport class EntityDispatcherFactory implements OnDestroy {\n  /**\n   * Actions scanned by the store after it processed them with reducers.\n   * A replay observable of the most recent action reduced by the store.\n   */\n  reducedActions$: Observable<Action>;\n  private raSubscription: Subscription;\n\n  constructor(\n    private entityActionFactory: EntityActionFactory,\n    private store: Store<EntityCache>,\n    private entityDispatcherDefaultOptions: EntityDispatcherDefaultOptions,\n    @Inject(ScannedActionsSubject) scannedActions$: Observable<Action>,\n    @Inject(ENTITY_CACHE_SELECTOR_TOKEN) private entityCacheSelector: EntityCacheSelector,\n    private correlationIdGenerator: CorrelationIdGenerator\n  ) {\n    // Replay because sometimes in tests will fake data service with synchronous observable\n    // which makes subscriber miss the dispatched actions.\n    // Of course that's a testing mistake. But easy to forget, leading to painful debugging.\n    this.reducedActions$ = scannedActions$.pipe(shareReplay(1));\n    // Start listening so late subscriber won't miss the most recent action.\n    this.raSubscription = this.reducedActions$.subscribe();\n  }\n\n  /**\n   * Create an `EntityDispatcher` for an entity type `T` and store.\n   */\n  create<T>(\n    /** Name of the entity type */\n    entityName: string,\n    /**\n     * Function that returns the primary key for an entity `T`.\n     * Usually acquired from `EntityDefinition` metadata.\n     */\n    selectId: IdSelector<T> = defaultSelectId,\n    /** Defaults for options that influence dispatcher behavior such as whether\n     * `add()` is optimistic or pessimistic;\n     */\n    defaultOptions: Partial<EntityDispatcherDefaultOptions> = {}\n  ): EntityDispatcher<T> {\n    // merge w/ defaultOptions with injected defaults\n    const options: EntityDispatcherDefaultOptions = { ...this.entityDispatcherDefaultOptions, ...defaultOptions };\n    return new EntityDispatcherBase<T>(\n      entityName,\n      this.entityActionFactory,\n      this.store,\n      selectId,\n      options,\n      this.reducedActions$,\n      this.entityCacheSelector,\n      this.correlationIdGenerator\n    );\n  }\n\n  ngOnDestroy() {\n    this.raSubscription.unsubscribe();\n  }\n}\n","import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { SchedulerLike } from 'rxjs';\n\n// See https://github.com/ReactiveX/rxjs/blob/master/doc/marble-testing.md\n/** Token to inject a special RxJS Scheduler during marble tests. */\nexport const ENTITY_EFFECTS_SCHEDULER = new InjectionToken<SchedulerLike>('EntityEffects Scheduler');\n","import { Inject, Injectable, Optional } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Actions, Effect, ofType } from '@ngrx/effects';\n\nimport { asyncScheduler, Observable, of, merge, race, SchedulerLike } from 'rxjs';\nimport { concatMap, catchError, delay, filter, map, mergeMap } from 'rxjs/operators';\n\nimport { DataServiceError } from '../dataservices/data-service-error';\nimport { ChangeSet, excludeEmptyChangeSetItems } from '../actions/entity-cache-change-set';\nimport { EntityActionFactory } from '../actions/entity-action-factory';\nimport { EntityOp } from '../actions/entity-op';\n\nimport {\n  EntityCacheAction,\n  SaveEntities,\n  SaveEntitiesCancel,\n  SaveEntitiesCanceled,\n  SaveEntitiesError,\n  SaveEntitiesSuccess\n} from '../actions/entity-cache-action';\nimport { EntityCacheDataService } from '../dataservices/entity-cache-data.service';\nimport { ENTITY_EFFECTS_SCHEDULER } from './entity-effects-scheduler';\nimport { Logger } from '../utils/interfaces';\nimport { PersistenceResultHandler } from '../dataservices/persistence-result-handler.service';\n\n@Injectable()\nexport class EntityCacheEffects {\n  // See https://github.com/ReactiveX/rxjs/blob/master/doc/marble-testing.md\n  /** Delay for error and skip observables. Must be multiple of 10 for marble testing. */\n  private responseDelay = 10;\n\n  constructor(\n    private actions: Actions,\n    private dataService: EntityCacheDataService,\n    private entityActionFactory: EntityActionFactory,\n    private logger: Logger,\n    /**\n     * Injecting an optional Scheduler that will be undefined\n     * in normal application usage, but its injected here so that you can mock out\n     * during testing using the RxJS TestScheduler for simulating passages of time.\n     */\n    @Optional()\n    @Inject(ENTITY_EFFECTS_SCHEDULER)\n    private scheduler: SchedulerLike\n  ) {}\n\n  /**\n   * Observable of SAVE_ENTITIES_CANCEL actions with non-null correlation ids\n   */\n  @Effect({ dispatch: false })\n  saveEntitiesCancel$: Observable<SaveEntitiesCancel> = this.actions.pipe(\n    ofType(EntityCacheAction.SAVE_ENTITIES_CANCEL),\n    filter((a: SaveEntitiesCancel) => a.payload.correlationId != null)\n  );\n\n  @Effect()\n  // Concurrent persistence requests considered unsafe.\n  // `mergeMap` allows for concurrent requests which may return in any order\n  saveEntities$: Observable<Action> = this.actions.pipe(\n    ofType(EntityCacheAction.SAVE_ENTITIES),\n    mergeMap((action: SaveEntities) => this.saveEntities(action))\n  );\n\n  /**\n   * Perform the requested SaveEntities actions and return a scalar Observable<Action>\n   * that the effect should dispatch to the store after the server responds.\n   * @param action The SaveEntities action\n   */\n  saveEntities(action: SaveEntities): Observable<Action> {\n    const error = action.payload.error;\n    if (error) {\n      return this.handleSaveEntitiesError$(action)(error);\n    }\n    try {\n      const changeSet = excludeEmptyChangeSetItems(action.payload.changeSet);\n      const { correlationId, mergeStrategy, tag, url } = action.payload;\n      const options = { correlationId, mergeStrategy, tag };\n\n      if (changeSet.changes.length === 0) {\n        // nothing to save\n        return of(new SaveEntitiesSuccess(changeSet, url, options));\n      }\n\n      // Cancellation: returns Observable<SaveEntitiesCanceled> for a saveEntities action\n      // whose correlationId matches the cancellation correlationId\n      const c = this.saveEntitiesCancel$.pipe(\n        filter(a => correlationId === a.payload.correlationId),\n        map(a => new SaveEntitiesCanceled(correlationId, a.payload.reason, a.payload.tag))\n      );\n\n      // Data: SaveEntities result as a SaveEntitiesSuccess action\n      const d = this.dataService\n        .saveEntities(changeSet, url)\n        .pipe(\n          concatMap(result =>\n            this.handleSaveEntitiesSuccess$(action, this.entityActionFactory)(result)\n          ),\n          catchError(this.handleSaveEntitiesError$(action))\n        );\n\n      // Emit which ever gets there first; the other observable is terminated.\n      return race(c, d);\n    } catch (err) {\n      return this.handleSaveEntitiesError$(action)(err);\n    }\n  }\n\n  /** return handler of error result of saveEntities, returning a scalar observable of error action */\n  private handleSaveEntitiesError$(\n    action: SaveEntities\n  ): (err: DataServiceError | Error) => Observable<Action> {\n    // Although error may return immediately,\n    // ensure observable takes some time,\n    // as app likely assumes asynchronous response.\n    return (err: DataServiceError | Error) => {\n      const error = err instanceof DataServiceError ? err : new DataServiceError(err, null);\n      return of(new SaveEntitiesError(error, action)).pipe(\n        delay(this.responseDelay, this.scheduler || asyncScheduler)\n      );\n    };\n  }\n\n  /** return handler of the ChangeSet result of successful saveEntities() */\n  private handleSaveEntitiesSuccess$(\n    action: SaveEntities,\n    entityActionFactory: EntityActionFactory\n  ): (changeSet: ChangeSet) => Observable<Action> {\n    const { url, correlationId, mergeStrategy, tag } = action.payload;\n    const options = { correlationId, mergeStrategy, tag };\n\n    return changeSet => {\n      // DataService returned a ChangeSet with possible updates to the saved entities\n      if (changeSet) {\n        return of(new SaveEntitiesSuccess(changeSet, url, options));\n      }\n\n      // No ChangeSet = Server probably responded '204 - No Content' because\n      // it made no changes to the inserted/updated entities.\n      // Respond with success action best on the ChangeSet in the request.\n      changeSet = action.payload.changeSet;\n\n      // If pessimistic save, return success action with the original ChangeSet\n      if (!action.payload.isOptimistic) {\n        return of(new SaveEntitiesSuccess(changeSet, url, options));\n      }\n\n      // If optimistic save, avoid cache grinding by just turning off the loading flags\n      // for all collections in the original ChangeSet\n      const entityNames = changeSet.changes.reduce(\n        (acc, item) => (acc.indexOf(item.entityName) === -1 ? acc.concat(item.entityName) : acc),\n        [] as string[]\n      );\n      return merge(\n        entityNames.map(name => entityActionFactory.create(name, EntityOp.SET_LOADING, false))\n      );\n    };\n  }\n}\n","import { Inject, Injectable, Optional } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Actions, Effect } from '@ngrx/effects';\n\nimport { asyncScheduler, Observable, of, race, SchedulerLike } from 'rxjs';\nimport { concatMap, catchError, delay, filter, map, mergeMap } from 'rxjs/operators';\n\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityActionFactory } from '../actions/entity-action-factory';\nimport { ENTITY_EFFECTS_SCHEDULER } from './entity-effects-scheduler';\nimport { EntityOp, makeSuccessOp } from '../actions/entity-op';\nimport { ofEntityOp } from '../actions/entity-action-operators';\nimport { Update } from '../utils/ngrx-entity-models';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\nimport { EntityDataService } from '../dataservices/entity-data.service';\nimport { PersistenceResultHandler } from '../dataservices/persistence-result-handler.service';\n\nexport const persistOps: EntityOp[] = [\n  EntityOp.QUERY_ALL,\n  EntityOp.QUERY_LOAD,\n  EntityOp.QUERY_BY_KEY,\n  EntityOp.QUERY_MANY,\n  EntityOp.SAVE_ADD_ONE,\n  EntityOp.SAVE_DELETE_ONE,\n  EntityOp.SAVE_UPDATE_ONE,\n  EntityOp.SAVE_UPSERT_ONE\n];\n\n@Injectable()\nexport class EntityEffects {\n  // See https://github.com/ReactiveX/rxjs/blob/master/doc/marble-testing.md\n  /** Delay for error and skip observables. Must be multiple of 10 for marble testing. */\n  private responseDelay = 10;\n\n  /**\n   * Observable of non-null cancellation correlation ids from CANCEL_PERSIST actions\n   */\n  @Effect({ dispatch: false })\n  cancel$: Observable<any> = this.actions.pipe(\n    ofEntityOp(EntityOp.CANCEL_PERSIST),\n    map((action: EntityAction) => action.payload.correlationId),\n    filter(id => id != null)\n  );\n\n  @Effect()\n  // `mergeMap` allows for concurrent requests which may return in any order\n  persist$: Observable<Action> = this.actions.pipe(\n    ofEntityOp(persistOps),\n    mergeMap(action => this.persist(action))\n  );\n\n  constructor(\n    private actions: Actions,\n    private dataService: EntityDataService,\n    private entityActionFactory: EntityActionFactory,\n    private resultHandler: PersistenceResultHandler,\n    /**\n     * Injecting an optional Scheduler that will be undefined\n     * in normal application usage, but its injected here so that you can mock out\n     * during testing using the RxJS TestScheduler for simulating passages of time.\n     */\n    @Optional()\n    @Inject(ENTITY_EFFECTS_SCHEDULER)\n    private scheduler: SchedulerLike\n  ) {}\n\n  /**\n   * Perform the requested persistence operation and return a scalar Observable<Action>\n   * that the effect should dispatch to the store after the server responds.\n   * @param action A persistence operation EntityAction\n   */\n  persist(action: EntityAction): Observable<Action> {\n    if (action.payload.skip) {\n      // Should not persist. Pretend it succeeded.\n      return this.handleSkipSuccess$(action);\n    }\n    if (action.payload.error) {\n      return this.handleError$(action)(action.payload.error);\n    }\n    try {\n      // Cancellation: returns Observable of CANCELED_PERSIST for a persistence EntityAction\n      // whose correlationId matches cancellation correlationId\n      const c = this.cancel$.pipe(\n        filter(id => action.payload.correlationId === id),\n        map(id =>\n          this.entityActionFactory.createFromAction(action, { entityOp: EntityOp.CANCELED_PERSIST })\n        )\n      );\n\n      // Data: entity collection DataService result as a successful persistence EntityAction\n      const d = this.callDataService(action).pipe(\n        map(this.resultHandler.handleSuccess(action)),\n        catchError(this.handleError$(action))\n      );\n\n      // Emit which ever gets there first; the other observable is terminated.\n      return race(c, d);\n    } catch (err) {\n      return this.handleError$(action)(err);\n    }\n  }\n\n  private callDataService(action: EntityAction) {\n    const { entityName, entityOp, data } = action.payload;\n    const service = this.dataService.getService(entityName);\n    switch (entityOp) {\n      case EntityOp.QUERY_ALL:\n      case EntityOp.QUERY_LOAD:\n        return service.getAll();\n\n      case EntityOp.QUERY_BY_KEY:\n        return service.getById(data);\n\n      case EntityOp.QUERY_MANY:\n        return service.getWithQuery(data);\n\n      case EntityOp.SAVE_ADD_ONE:\n        return service.add(data);\n\n      case EntityOp.SAVE_DELETE_ONE:\n        return service.delete(data);\n\n      case EntityOp.SAVE_UPDATE_ONE:\n        const { id, changes } = data as Update<any>; // data must be Update<T>\n        return service.update(data).pipe(\n          map(updatedEntity => {\n            // Return an Update<T> with updated entity data.\n            // If server returned entity data, merge with the changes that were sent\n            // and set the 'changed' flag to true.\n            // If server did not return entity data,\n            // assume it made no additional changes of its own, return the original changes,\n            // and set the `changed` flag to `false`.\n            const hasData = updatedEntity && Object.keys(updatedEntity).length > 0;\n            const responseData: UpdateResponseData<any> = hasData\n              ? { id, changes: { ...changes, ...updatedEntity }, changed: true }\n              : { id, changes, changed: false };\n            return responseData;\n          })\n        );\n\n      case EntityOp.SAVE_UPSERT_ONE:\n        return service.upsert(data).pipe(\n          map(upsertedEntity => {\n            const hasData = upsertedEntity && Object.keys(upsertedEntity).length > 0;\n            return hasData ? upsertedEntity : data; // ensure a returned entity value.\n          })\n        );\n      default:\n        throw new Error(`Persistence action \"${entityOp}\" is not implemented.`);\n    }\n  }\n\n  /**\n   * Handle error result of persistence operation on an EntityAction,\n   * returning a scalar observable of error action\n   */\n  private handleError$(action: EntityAction): (error: Error) => Observable<EntityAction> {\n    // Although error may return immediately,\n    // ensure observable takes some time,\n    // as app likely assumes asynchronous response.\n    return (error: Error) =>\n      of(this.resultHandler.handleError(action)(error)).pipe(\n        delay(this.responseDelay, this.scheduler || asyncScheduler)\n      );\n  }\n\n  /**\n   * Because EntityAction.payload.skip is true, skip the persistence step and\n   * return a scalar success action that looks like the operation succeeded.\n   */\n  private handleSkipSuccess$(originalAction: EntityAction): Observable<EntityAction> {\n    const successOp = makeSuccessOp(originalAction.payload.entityOp);\n    const successAction = this.entityActionFactory.createFromAction(originalAction, {\n      entityOp: successOp\n    });\n    // Although returns immediately,\n    // ensure observable takes one tick (by using a promise),\n    // as app likely assumes asynchronous response.\n    return of(successAction).pipe(delay(this.responseDelay, this.scheduler || asyncScheduler));\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Action, Store } from '@ngrx/store';\nimport { Actions } from '@ngrx/effects';\n\nimport { Observable } from 'rxjs';\n\nimport { Dictionary, IdSelector, Update } from '../utils/ngrx-entity-models';\nimport { EntityAction, EntityActionOptions } from '../actions/entity-action';\nimport { EntityActionGuard } from '../actions/entity-action-guard';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityCollection, ChangeStateMap } from '../reducers/entity-collection';\nimport { EntityDispatcher } from '../dispatchers/entity-dispatcher';\nimport { EntityCollectionService } from './entity-collection-service';\nimport { EntityCollectionServiceElementsFactory } from './entity-collection-service-elements-factory';\nimport { EntityOp } from '../actions/entity-op';\nimport { EntitySelectors } from '../selectors/entity-selectors';\nimport { EntitySelectors$ } from '../selectors/entity-selectors$';\nimport { QueryParams } from '../dataservices/interfaces';\n\n// tslint:disable:member-ordering\n\n/**\n * Base class for a concrete EntityCollectionService<T>.\n * Can be instantiated. Cannot be injected. Use EntityCollectionServiceFactory to create.\n * @param EntityCollectionServiceElements The ingredients for this service\n * as a source of supporting services for creating an EntityCollectionService<T> instance.\n */\nexport class EntityCollectionServiceBase<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>\n  implements EntityCollectionService<T> {\n  /** Dispatcher of EntityCommands (EntityActions) */\n  readonly dispatcher: EntityDispatcher<T>;\n\n  /** All selectors of entity collection properties */\n  readonly selectors: EntitySelectors<T>;\n\n  /** All selectors$ (observables of entity collection properties) */\n  readonly selectors$: S$;\n\n  constructor(\n    /** Name of the entity type of this collection service */\n    public readonly entityName: string,\n    /** Creates the core elements of the EntityCollectionService for this entity type */\n    serviceElementsFactory: EntityCollectionServiceElementsFactory\n  ) {\n    entityName = entityName.trim();\n    const { dispatcher, selectors, selectors$ } = serviceElementsFactory.create<T, S$>(entityName);\n\n    this.entityName = entityName;\n    this.dispatcher = dispatcher;\n    this.guard = dispatcher.guard;\n    this.selectId = dispatcher.selectId;\n    this.toUpdate = dispatcher.toUpdate;\n\n    this.selectors = selectors;\n    this.selectors$ = selectors$;\n    this.collection$ = selectors$.collection$;\n    this.count$ = selectors$.count$;\n    this.entities$ = selectors$.entities$;\n    this.entityActions$ = selectors$.entityActions$;\n    this.entityMap$ = selectors$.entityMap$;\n    this.errors$ = selectors$.errors$;\n    this.filter$ = selectors$.filter$;\n    this.filteredEntities$ = selectors$.filteredEntities$;\n    this.keys$ = selectors$.keys$;\n    this.loaded$ = selectors$.loaded$;\n    this.loading$ = selectors$.loading$;\n    this.changeState$ = selectors$.changeState$;\n  }\n\n  /**\n   * Create an {EntityAction} for this entity type.\n   * @param op {EntityOp} the entity operation\n   * @param [data] the action data\n   * @param [options] additional options\n   * @returns the EntityAction\n   */\n  createEntityAction<P = any>(\n    op: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P> {\n    return this.dispatcher.createEntityAction(op, data, options);\n  }\n\n  /**\n   * Create an {EntityAction} for this entity type and\n   * dispatch it immediately to the store.\n   * @param op {EntityOp} the entity operation\n   * @param [data] the action data\n   * @param [options] additional options\n   * @returns the dispatched EntityAction\n   */\n  createAndDispatch<P = any>(\n    op: EntityOp,\n    data?: P,\n    options?: EntityActionOptions\n  ): EntityAction<P> {\n    return this.dispatcher.createAndDispatch(op, data, options);\n  }\n\n  /**\n   * Dispatch an action of any type to the ngrx store.\n   * @param action the Action\n   * @returns the dispatched Action\n   */\n  dispatch(action: Action): Action {\n    return this.dispatcher.dispatch(action);\n  }\n\n  /** The NgRx Store for the {EntityCache} */\n  get store() {\n    return this.dispatcher.store;\n  }\n\n  /**\n   * Utility class with methods to validate EntityAction payloads.\n   */\n  guard: EntityActionGuard;\n\n  /** Returns the primary key (id) of this entity */\n  selectId: IdSelector<T>;\n\n  /**\n   * Convert an entity (or partial entity) into the `Update<T>` object\n   * `update...` and `upsert...` methods take `Update<T>` args\n   */\n  toUpdate: (entity: Partial<T>) => Update<T>;\n\n  // region Dispatch commands\n\n  /**\n   * Dispatch action to save a new entity to remote storage.\n   * @param entity entity to add, which may omit its key if pessimistic and the server creates the key;\n   * must have a key if optimistic save.\n   * @param [options] options that influence save and merge behavior\n   * @returns Observable of the entity\n   * after server reports successful save or the save error.\n   */\n  add(entity: T, options?: EntityActionOptions): Observable<T> {\n    return this.dispatcher.add(entity, options);\n  }\n\n  /**\n   * Dispatch action to cancel the persistence operation (query or save) with the given correlationId.\n   * @param correlationId The correlation id for the corresponding EntityAction\n   * @param [reason] explains why canceled and by whom.\n   * @param [options] options such as the tag\n   */\n  cancel(correlationId: any, reason?: string, options?: EntityActionOptions): void {\n    this.dispatcher.cancel(correlationId, reason, options);\n  }\n\n  /**\n   * Dispatch action to delete entity from remote storage by key.\n   * @param key The entity to delete\n   * @param [options] options that influence save and merge behavior\n   * @returns Observable of the deleted key\n   * after server reports successful save or the save error.\n   */\n  delete(entity: T, options?: EntityActionOptions): Observable<number | string>;\n\n  /**\n   * Dispatch action to delete entity from remote storage by key.\n   * @param key The primary key of the entity to remove\n   * @param [options] options that influence save and merge behavior\n   * @returns Observable of the deleted key\n   * after server reports successful save or the save error.\n   */\n  delete(key: number | string, options?: EntityActionOptions): Observable<number | string>;\n  delete(arg: number | string | T, options?: EntityActionOptions): Observable<number | string> {\n    return this.dispatcher.delete(arg as any, options);\n  }\n\n  /**\n   * Dispatch action to query remote storage for all entities and\n   * merge the queried entities into the cached collection.\n   * @param [options] options that influence merge behavior\n   * @returns Observable of the collection\n   * after server reports successful query or the query error.\n   * @see load()\n   */\n  getAll(options?: EntityActionOptions): Observable<T[]> {\n    return this.dispatcher.getAll(options);\n  }\n\n  /**\n   * Dispatch action to query remote storage for the entity with this primary key.\n   * If the server returns an entity,\n   * merge it into the cached collection.\n   * @param key The primary key of the entity to get.\n   * @param [options] options that influence merge behavior\n   * @returns Observable of the queried entity that is in the collection\n   * after server reports success or the query error.\n   */\n  getByKey(key: any, options?: EntityActionOptions): Observable<T> {\n    return this.dispatcher.getByKey(key, options);\n  }\n\n  /**\n   * Dispatch action to query remote storage for the entities that satisfy a query expressed\n   * with either a query parameter map or an HTTP URL query string,\n   * and merge the results into the cached collection.\n   * @params queryParams the query in a form understood by the server\n   * @param [options] options that influence merge behavior\n   * @returns Observable of the queried entities\n   * after server reports successful query or the query error.\n   */\n  getWithQuery(queryParams: QueryParams | string, options?: EntityActionOptions): Observable<T[]> {\n    return this.dispatcher.getWithQuery(queryParams, options);\n  }\n\n  /**\n   * Dispatch action to query remote storage for all entities and\n   * completely replace the cached collection with the queried entities.\n   * @param [options] options that influence load behavior\n   * @returns Observable of the collection\n   * after server reports successful query or the query error.\n   * @see getAll\n   */\n  load(options?: EntityActionOptions): Observable<T[]> {\n    return this.dispatcher.load(options);\n  }\n\n  /**\n   * Dispatch action to save the updated entity (or partial entity) in remote storage.\n   * The update entity may be partial (but must have its key)\n   * in which case it patches the existing entity.\n   * @param entity update entity, which might be a partial of T but must at least have its key.\n   * @param [options] options that influence save and merge behavior\n   * @returns Observable of the updated entity\n   * after server reports successful save or the save error.\n   */\n  update(entity: Partial<T>, options?: EntityActionOptions): Observable<T> {\n    return this.dispatcher.update(entity, options);\n  }\n\n  /**\n   * Dispatch action to save a new or existing entity to remote storage.\n   * Call only if the server supports upsert.\n   * @param entity entity to add or upsert.\n   * It may omit its key if an add, and is pessimistic, and the server creates the key;\n   * must have a key if optimistic save.\n   * @param [options] options that influence save and merge behavior\n   * @returns Observable of the entity\n   * after server reports successful save or the save error.\n   */\n  upsert(entity: T, options?: EntityActionOptions): Observable<T> {\n    return this.dispatcher.upsert(entity, options);\n  }\n\n  /*** Cache-only operations that do not update remote storage ***/\n\n  /**\n   * Replace all entities in the cached collection.\n   * Does not save to remote storage.\n   */\n  addAllToCache(entities: T[]): void {\n    this.dispatcher.addAllToCache(entities);\n  }\n\n  /**\n   * Add a new entity directly to the cache.\n   * Does not save to remote storage.\n   * Ignored if an entity with the same primary key is already in cache.\n   */\n  addOneToCache(entity: T): void {\n    this.dispatcher.addOneToCache(entity);\n  }\n\n  /**\n   * Add multiple new entities directly to the cache.\n   * Does not save to remote storage.\n   * Entities with primary keys already in cache are ignored.\n   */\n  addManyToCache(entities: T[]): void {\n    this.dispatcher.addManyToCache(entities);\n  }\n\n  /** Clear the cached entity collection */\n  clearCache(): void {\n    this.dispatcher.clearCache();\n  }\n\n  /**\n   * Remove an entity directly from the cache.\n   * Does not delete that entity from remote storage.\n   * @param entity The entity to remove\n   */\n  removeOneFromCache(entity: T): void;\n\n  /**\n   * Remove an entity directly from the cache.\n   * Does not delete that entity from remote storage.\n   * @param key The primary key of the entity to remove\n   */\n  removeOneFromCache(key: number | string): void;\n  removeOneFromCache(arg: (number | string) | T): void {\n    this.dispatcher.removeOneFromCache(arg as any);\n  }\n\n  /**\n   * Remove multiple entities directly from the cache.\n   * Does not delete these entities from remote storage.\n   * @param entity The entities to remove\n   */\n  removeManyFromCache(entities: T[]): void;\n\n  /**\n   * Remove multiple entities directly from the cache.\n   * Does not delete these entities from remote storage.\n   * @param keys The primary keys of the entities to remove\n   */\n  removeManyFromCache(keys: (number | string)[]): void;\n  removeManyFromCache(args: (number | string)[] | T[]): void {\n    this.dispatcher.removeManyFromCache(args as any[]);\n  }\n\n  /**\n   * Update a cached entity directly.\n   * Does not update that entity in remote storage.\n   * Ignored if an entity with matching primary key is not in cache.\n   * The update entity may be partial (but must have its key)\n   * in which case it patches the existing entity.\n   */\n  updateOneInCache(entity: Partial<T>): void {\n    // update entity might be a partial of T but must at least have its key.\n    // pass the Update<T> structure as the payload\n    this.dispatcher.updateOneInCache(entity);\n  }\n\n  /**\n   * Update multiple cached entities directly.\n   * Does not update these entities in remote storage.\n   * Entities whose primary keys are not in cache are ignored.\n   * Update entities may be partial but must at least have their keys.\n   * such partial entities patch their cached counterparts.\n   */\n  updateManyInCache(entities: Partial<T>[]): void {\n    this.dispatcher.updateManyInCache(entities);\n  }\n\n  /**\n   * Add or update a new entity directly to the cache.\n   * Does not save to remote storage.\n   * Upsert entity might be a partial of T but must at least have its key.\n   * Pass the Update<T> structure as the payload\n   */\n  upsertOneInCache(entity: Partial<T>): void {\n    this.dispatcher.upsertOneInCache(entity);\n  }\n\n  /**\n   * Add or update multiple cached entities directly.\n   * Does not save to remote storage.\n   */\n  upsertManyInCache(entities: Partial<T>[]): void {\n    this.dispatcher.upsertManyInCache(entities);\n  }\n\n  /**\n   * Set the pattern that the collection's filter applies\n   * when using the `filteredEntities` selector.\n   */\n  setFilter(pattern: any): void {\n    this.dispatcher.setFilter(pattern);\n  }\n\n  /** Set the loaded flag */\n  setLoaded(isLoaded: boolean): void {\n    this.dispatcher.setLoaded(!!isLoaded);\n  }\n\n  /** Set the loading flag */\n  setLoading(isLoading: boolean): void {\n    this.dispatcher.setLoading(!!isLoading);\n  }\n\n  // endregion Dispatch commands\n\n  // region Selectors$\n  /** Observable of the collection as a whole */\n  collection$: Observable<EntityCollection<T>> | Store<EntityCollection<T>>;\n\n  /** Observable of count of entities in the cached collection. */\n  count$: Observable<number> | Store<number>;\n\n  /** Observable of all entities in the cached collection. */\n  entities$: Observable<T[]> | Store<T[]>;\n\n  /** Observable of actions related to this entity type. */\n  entityActions$: Observable<EntityAction>;\n\n  /** Observable of the map of entity keys to entities */\n  entityMap$: Observable<Dictionary<T>> | Store<Dictionary<T>>;\n\n  /** Observable of error actions related to this entity type. */\n  errors$: Observable<EntityAction>;\n\n  /** Observable of the filter pattern applied by the entity collection's filter function */\n  filter$: Observable<string> | Store<string>;\n\n  /** Observable of entities in the cached collection that pass the filter function */\n  filteredEntities$: Observable<T[]> | Store<T[]>;\n\n  /** Observable of the keys of the cached collection, in the collection's native sort order */\n  keys$: Observable<string[] | number[]> | Store<string[] | number[]>;\n\n  /** Observable true when the collection has been loaded */\n  loaded$: Observable<boolean> | Store<boolean>;\n\n  /** Observable true when a multi-entity query command is in progress. */\n  loading$: Observable<boolean> | Store<boolean>;\n\n  /** Original entity values for entities with unsaved changes */\n  changeState$: Observable<ChangeStateMap<T>> | Store<ChangeStateMap<T>>;\n\n  // endregion Selectors$\n}\n","import { Injectable, Optional } from '@angular/core';\n\nimport { EntityCollection } from './entity-collection';\nimport { EntityDefinitionService } from '../entity-metadata/entity-definition.service';\n\n@Injectable()\nexport class EntityCollectionCreator {\n  constructor(@Optional() private entityDefinitionService?: EntityDefinitionService) {}\n\n  /**\n   * Create the default collection for an entity type.\n   * @param entityName {string} entity type name\n   */\n  create<T = any, S extends EntityCollection<T> = EntityCollection<T>>(entityName: string): S {\n    const def = this.entityDefinitionService && this.entityDefinitionService.getDefinition<T>(entityName, false /*shouldThrow*/);\n\n    const initialState = def && def.initialState;\n\n    return <S>(initialState || createEmptyEntityCollection<T>(entityName));\n  }\n}\n\nexport function createEmptyEntityCollection<T>(entityName?: string): EntityCollection<T> {\n  return {\n    entityName,\n    ids: [],\n    entities: {},\n    filter: undefined,\n    loaded: false,\n    loading: false,\n    changeState: {}\n  } as EntityCollection<T>;\n}\n","import { Inject, Injectable, Optional } from '@angular/core';\n\n// Prod build requires `MemoizedSelector even though not used.\nimport { MemoizedSelector } from '@ngrx/store';\nimport { createFeatureSelector, createSelector, Selector } from '@ngrx/store';\n\nimport { Observable } from 'rxjs';\n\nimport { Dictionary } from '../utils/ngrx-entity-models';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { ENTITY_CACHE_SELECTOR_TOKEN, EntityCacheSelector, createEntityCacheSelector } from './entity-cache-selector';\nimport { ENTITY_CACHE_NAME } from '../reducers/constants';\nimport { EntityCollection, ChangeStateMap } from '../reducers/entity-collection';\nimport { EntityCollectionCreator } from '../reducers/entity-collection-creator';\nimport { EntityFilterFn } from '../entity-metadata/entity-filters';\nimport { EntityMetadata } from '../entity-metadata/entity-metadata';\n\n/**\n * The selector functions for entity collection members,\n * Selects from the entity collection to the collection member\n * Contrast with {EntitySelectors}.\n */\nexport interface CollectionSelectors<T> {\n  readonly [selector: string]: any;\n\n  /** Count of entities in the cached collection. */\n  readonly selectCount: Selector<EntityCollection<T>, number>;\n\n  /** All entities in the cached collection. */\n  readonly selectEntities: Selector<EntityCollection<T>, T[]>;\n\n  /** Map of entity keys to entities */\n  readonly selectEntityMap: Selector<EntityCollection<T>, Dictionary<T>>;\n\n  /** Filter pattern applied by the entity collection's filter function */\n  readonly selectFilter: Selector<EntityCollection<T>, string>;\n\n  /** Entities in the cached collection that pass the filter function */\n  readonly selectFilteredEntities: Selector<EntityCollection<T>, T[]>;\n\n  /** Keys of the cached collection, in the collection's native sort order */\n  readonly selectKeys: Selector<EntityCollection<T>, string[] | number[]>;\n\n  /** True when the collection has been fully loaded. */\n  readonly selectLoaded: Selector<EntityCollection<T>, boolean>;\n\n  /** True when a multi-entity query command is in progress. */\n  readonly selectLoading: Selector<EntityCollection<T>, boolean>;\n\n  /** ChangeState (including original values) of entities with unsaved changes */\n  readonly selectChangeState: Selector<EntityCollection<T>, ChangeStateMap<T>>;\n}\n\n/**\n * The selector functions for entity collection members,\n * Selects from store root, through EntityCache, to the entity collection member\n * Contrast with {CollectionSelectors}.\n */\nexport interface EntitySelectors<T> {\n  /** Name of the entity collection for these selectors */\n  readonly entityName: string;\n\n  readonly [name: string]: MemoizedSelector<EntityCollection<T>, any> | string;\n\n  /** The cached EntityCollection itself */\n  readonly selectCollection: MemoizedSelector<Object, EntityCollection<T>>;\n\n  /** Count of entities in the cached collection. */\n  readonly selectCount: MemoizedSelector<Object, number>;\n\n  /** All entities in the cached collection. */\n  readonly selectEntities: MemoizedSelector<Object, T[]>;\n\n  /** The EntityCache */\n  readonly selectEntityCache: MemoizedSelector<Object, EntityCache>;\n\n  /** Map of entity keys to entities */\n  readonly selectEntityMap: MemoizedSelector<Object, Dictionary<T>>;\n\n  /** Filter pattern applied by the entity collection's filter function */\n  readonly selectFilter: MemoizedSelector<Object, string>;\n\n  /** Entities in the cached collection that pass the filter function */\n  readonly selectFilteredEntities: MemoizedSelector<Object, T[]>;\n\n  /** Keys of the cached collection, in the collection's native sort order */\n  readonly selectKeys: MemoizedSelector<Object, string[] | number[]>;\n\n  /** True when the collection has been fully loaded. */\n  readonly selectLoaded: MemoizedSelector<Object, boolean>;\n\n  /** True when a multi-entity query command is in progress. */\n  readonly selectLoading: MemoizedSelector<Object, boolean>;\n\n  /** ChangeState (including original values) of entities with unsaved changes */\n  readonly selectChangeState: MemoizedSelector<Object, ChangeStateMap<T>>;\n}\n\n/** Creates EntitySelector functions for entity collections. */\n@Injectable()\nexport class EntitySelectorsFactory {\n  constructor(\n    @Optional() private entityCollectionCreator?: EntityCollectionCreator,\n    @Optional()\n    @Inject(ENTITY_CACHE_SELECTOR_TOKEN)\n    private selectEntityCache?: EntityCacheSelector\n  ) {\n    this.entityCollectionCreator = entityCollectionCreator || new EntityCollectionCreator();\n    this.selectEntityCache = selectEntityCache || createEntityCacheSelector(ENTITY_CACHE_NAME);\n  }\n\n  /**\n   * Create the NgRx selector from the store root to the named collection,\n   * e.g. from Object to Heroes.\n   * @param entityName the name of the collection\n   */\n  createCollectionSelector<T = any, C extends EntityCollection<T> = EntityCollection<T>>(entityName: string) {\n    const getCollection = (cache: EntityCache = {}) => <C>(cache[entityName] || this.entityCollectionCreator.create<T>(entityName));\n    return createSelector(this.selectEntityCache, getCollection);\n  }\n\n  /////// createCollectionSelectors //////////\n\n  // Based on @ngrx/entity/state_selectors.ts\n\n  // tslint:disable:unified-signatures\n  // createCollectionSelectors(metadata) overload\n  /**\n   * Creates entity collection selectors from metadata.\n   * @param metadata - EntityMetadata for the collection.\n   * May be partial but much have `entityName`.\n   */\n  createCollectionSelectors<T, S extends CollectionSelectors<T> = CollectionSelectors<T>>(metadata: EntityMetadata<T>): S;\n\n  // tslint:disable:unified-signatures\n  // createCollectionSelectors(entityName) overload\n  /**\n   * Creates default entity collection selectors for an entity type.\n   * Use the metadata overload for additional collection selectors.\n   * @param entityName - name of the entity type\n   */\n  createCollectionSelectors<T, S extends CollectionSelectors<T> = CollectionSelectors<T>>(entityName: string): S;\n\n  // createCollectionSelectors implementation\n  createCollectionSelectors<T, S extends CollectionSelectors<T> = CollectionSelectors<T>>(metadataOrName: EntityMetadata<T> | string): S {\n    const metadata = typeof metadataOrName === 'string' ? { entityName: metadataOrName } : metadataOrName;\n    const selectKeys = (c: EntityCollection<T>) => c.ids;\n    const selectEntityMap = (c: EntityCollection<T>) => c.entities;\n\n    const selectEntities: Selector<EntityCollection<T>, T[]> = createSelector(\n      selectKeys,\n      selectEntityMap,\n      (keys: (number | string)[], entities: Dictionary<T>): T[] => keys.map(key => entities[key] as T)\n    );\n\n    const selectCount: Selector<EntityCollection<T>, number> = createSelector(selectKeys, keys => keys.length);\n\n    // EntityCollection selectors that go beyond the ngrx/entity/EntityState selectors\n    const selectFilter = (c: EntityCollection<T>) => c.filter;\n\n    const filterFn = metadata.filterFn;\n    const selectFilteredEntities: Selector<EntityCollection<T>, T[]> = filterFn\n      ? createSelector(selectEntities, selectFilter, (entities: T[], pattern: any): T[] => filterFn(entities, pattern))\n      : selectEntities;\n\n    const selectLoaded = (c: EntityCollection<T>) => c.loaded;\n    const selectLoading = (c: EntityCollection<T>) => c.loading;\n    const selectChangeState = (c: EntityCollection<T>) => c.changeState;\n\n    // Create collection selectors for each `additionalCollectionState` property.\n    // These all extend from `selectCollection`\n    const extra = metadata.additionalCollectionState || {};\n    const extraSelectors: {\n      [name: string]: Selector<EntityCollection<T>, any>;\n    } = {};\n    Object.keys(extra).forEach(k => {\n      extraSelectors['select' + k[0].toUpperCase() + k.slice(1)] = (c: EntityCollection<T>) => (<any>c)[k];\n    });\n\n    return {\n      selectCount,\n      selectEntities,\n      selectEntityMap,\n      selectFilter,\n      selectFilteredEntities,\n      selectKeys,\n      selectLoaded,\n      selectLoading,\n      selectChangeState,\n      ...extraSelectors\n    } as S;\n  }\n\n  /////// create //////////\n\n  // create(metadata) overload\n  /**\n   * Creates the store-rooted selectors for an entity collection.\n   * {EntitySelectors$Factory} turns them into selectors$.\n   *\n   * @param metadata - EntityMetadata for the collection.\n   * May be partial but much have `entityName`.\n   *\n   * Based on ngrx/entity/state_selectors.ts\n   * Differs in that these selectors select from the NgRx store root,\n   * through the collection, to the collection members.\n   */\n  create<T, S extends EntitySelectors<T> = EntitySelectors<T>>(metadata: EntityMetadata<T>): S;\n\n  // create(entityName) overload\n  /**\n   * Creates the default store-rooted selectors for an entity collection.\n   * {EntitySelectors$Factory} turns them into selectors$.\n   * Use the metadata overload for additional collection selectors.\n   *\n   * @param entityName - name of the entity type.\n   *\n   * Based on ngrx/entity/state_selectors.ts\n   * Differs in that these selectors select from the NgRx store root,\n   * through the collection, to the collection members.\n   */\n  create<T, S extends EntitySelectors<T> = EntitySelectors<T>>(\n    // tslint:disable-next-line:unified-signatures\n    entityName: string\n  ): S;\n\n  // createCollectionSelectors implementation\n  create<T, S extends EntitySelectors<T> = EntitySelectors<T>>(metadataOrName: EntityMetadata<T> | string): S {\n    const metadata = typeof metadataOrName === 'string' ? { entityName: metadataOrName } : metadataOrName;\n    const entityName = metadata.entityName;\n    const selectCollection: Selector<Object, EntityCollection<T>> = this.createCollectionSelector<T>(entityName);\n    const collectionSelectors = this.createCollectionSelectors<T>(metadata);\n\n    const entitySelectors: {\n      [name: string]: Selector<EntityCollection<T>, any>;\n    } = {};\n    Object.keys(collectionSelectors).forEach(k => {\n      entitySelectors[k] = createSelector(selectCollection, collectionSelectors[k]);\n    });\n\n    return {\n      entityName,\n      selectCollection,\n      selectEntityCache: this.selectEntityCache,\n      ...entitySelectors\n    } as S;\n  }\n}\n","import { Inject, Injectable } from '@angular/core';\n\nimport { createFeatureSelector, createSelector, Selector, Store } from '@ngrx/store';\nimport { Actions } from '@ngrx/effects';\n\nimport { Observable } from 'rxjs';\nimport { filter, shareReplay } from 'rxjs/operators';\n\nimport { Dictionary } from '../utils/ngrx-entity-models';\nimport { EntityAction } from '../actions/entity-action';\nimport { OP_ERROR } from '../actions/entity-op';\nimport { ofEntityType } from '../actions/entity-action-operators';\nimport { ENTITY_CACHE_SELECTOR_TOKEN, EntityCacheSelector } from './entity-cache-selector';\nimport { EntitySelectors } from './entity-selectors';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityCollection, ChangeStateMap } from '../reducers/entity-collection';\nimport { EntityCollectionCreator } from '../reducers/entity-collection-creator';\nimport { EntitySelectorsFactory } from './entity-selectors';\n\n/**\n * The selector observable functions for entity collection members.\n */\nexport interface EntitySelectors$<T> {\n  /** Name of the entity collection for these selectors$ */\n  readonly entityName: string;\n\n  /** Observable of the collection as a whole */\n  readonly collection$: Observable<EntityCollection> | Store<EntityCollection>;\n\n  /** Observable of count of entities in the cached collection. */\n  readonly count$: Observable<number> | Store<number>;\n\n  /** Observable of all entities in the cached collection. */\n  readonly entities$: Observable<T[]> | Store<T[]>;\n\n  /** Observable of actions related to this entity type. */\n  readonly entityActions$: Observable<EntityAction>;\n\n  /** Observable of the map of entity keys to entities */\n  readonly entityMap$: Observable<Dictionary<T>> | Store<Dictionary<T>>;\n\n  /** Observable of error actions related to this entity type. */\n  readonly errors$: Observable<EntityAction>;\n\n  /** Observable of the filter pattern applied by the entity collection's filter function */\n  readonly filter$: Observable<string> | Store<string>;\n\n  /** Observable of entities in the cached collection that pass the filter function */\n  readonly filteredEntities$: Observable<T[]> | Store<T[]>;\n\n  /** Observable of the keys of the cached collection, in the collection's native sort order */\n  readonly keys$: Observable<string[] | number[]> | Store<string[] | number[]>;\n\n  /** Observable true when the collection has been loaded */\n  readonly loaded$: Observable<boolean> | Store<boolean>;\n\n  /** Observable true when a multi-entity query command is in progress. */\n  readonly loading$: Observable<boolean> | Store<boolean>;\n\n  /** ChangeState (including original values) of entities with unsaved changes */\n  readonly changeState$: Observable<ChangeStateMap<T>> | Store<ChangeStateMap<T>>;\n}\n\n/** Creates observable EntitySelectors$ for entity collections. */\n@Injectable()\nexport class EntitySelectors$Factory {\n  /** Observable of the EntityCache */\n  entityCache$: Observable<EntityCache>;\n\n  /** Observable of error EntityActions (e.g. QUERY_ALL_ERROR) for all entity types */\n  entityActionErrors$: Observable<EntityAction>;\n\n  constructor(\n    private store: Store<any>,\n    private actions: Actions,\n    @Inject(ENTITY_CACHE_SELECTOR_TOKEN) private selectEntityCache: EntityCacheSelector\n  ) {\n    // This service applies to the cache in ngrx/store named `cacheName`\n    this.entityCache$ = this.store.select(this.selectEntityCache);\n    this.entityActionErrors$ = actions.pipe(\n      filter((ea: EntityAction) => ea.payload && ea.payload.entityOp && ea.payload.entityOp.endsWith(OP_ERROR)),\n      shareReplay(1)\n    );\n  }\n\n  /**\n   * Creates an entity collection's selectors$ observables for this factory's store.\n   * `selectors$` are observable selectors of the cached entity collection.\n   * @param entityName - is also the name of the collection.\n   * @param selectors - selector functions for this collection.\n   **/\n  create<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(entityName: string, selectors?: EntitySelectors<T>): S$ {\n    const selectors$: { [prop: string]: any } = {\n      entityName\n    };\n\n    Object.keys(selectors).forEach(name => {\n      if (name.startsWith('select')) {\n        // strip 'select' prefix from the selector fn name and append `$`\n        // Ex: 'selectEntities' => 'entities$'\n        const name$ = name[6].toLowerCase() + name.substr(7) + '$';\n        selectors$[name$] = this.store.select((<any>selectors)[name]);\n      }\n    });\n    selectors$.entityActions$ = this.actions.pipe(ofEntityType(entityName));\n    selectors$.errors$ = this.entityActionErrors$.pipe(ofEntityType(entityName));\n    return selectors$ as S$;\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { EntityCollectionService } from './entity-collection-service';\nimport { EntityCollectionServiceBase } from './entity-collection-service-base';\nimport { EntityDispatcher } from '../dispatchers/entity-dispatcher';\nimport { EntityDispatcherFactory } from '../dispatchers/entity-dispatcher-factory';\nimport { EntityDefinitionService } from '../entity-metadata/entity-definition.service';\nimport { EntitySelectors, EntitySelectorsFactory } from '../selectors/entity-selectors';\nimport { EntitySelectors$, EntitySelectors$Factory } from '../selectors/entity-selectors$';\n\n/** Core ingredients of an EntityCollectionService */\nexport interface EntityCollectionServiceElements<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>> {\n  readonly dispatcher: EntityDispatcher<T>;\n  readonly entityName: string;\n  readonly selectors: EntitySelectors<T>;\n  readonly selectors$: S$;\n}\n\n/** Creates the core elements of the EntityCollectionService for an entity type. */\n@Injectable()\nexport class EntityCollectionServiceElementsFactory {\n  constructor(\n    private entityDispatcherFactory: EntityDispatcherFactory,\n    private entityDefinitionService: EntityDefinitionService,\n    private entitySelectorsFactory: EntitySelectorsFactory,\n    private entitySelectors$Factory: EntitySelectors$Factory\n  ) {}\n\n  /**\n   * Get the ingredients for making an EntityCollectionService for this entity type\n   * @param entityName - name of the entity type\n   */\n  create<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(entityName: string): EntityCollectionServiceElements<T, S$> {\n    entityName = entityName.trim();\n    const definition = this.entityDefinitionService.getDefinition<T>(entityName);\n    const dispatcher = this.entityDispatcherFactory.create<T>(entityName, definition.selectId, definition.entityDispatcherOptions);\n    const selectors = this.entitySelectorsFactory.create<T>(definition.metadata);\n    const selectors$ = this.entitySelectors$Factory.create<T, S$>(entityName, selectors);\n    return {\n      dispatcher,\n      entityName,\n      selectors,\n      selectors$\n    };\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { EntityCollectionService } from './entity-collection-service';\nimport { EntityCollectionServiceBase } from './entity-collection-service-base';\nimport { EntityCollectionServiceElementsFactory } from './entity-collection-service-elements-factory';\nimport { EntitySelectors$ } from '../selectors/entity-selectors$';\n\n/**\n * Creates EntityCollectionService instances for\n * a cached collection of T entities in the ngrx store.\n */\n@Injectable()\nexport class EntityCollectionServiceFactory {\n  constructor(\n    /** Creates the core elements of the EntityCollectionService for an entity type. */\n    public entityCollectionServiceElementsFactory: EntityCollectionServiceElementsFactory\n  ) {}\n\n  /**\n   * Create an EntityCollectionService for an entity type\n   * @param entityName - name of the entity type\n   */\n  create<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(entityName: string): EntityCollectionService<T> {\n    return new EntityCollectionServiceBase<T, S$>(entityName, this.entityCollectionServiceElementsFactory);\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Action, Store } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityDispatcherFactory } from '../dispatchers/entity-dispatcher-factory';\nimport { EntitySelectors$Factory } from '../selectors/entity-selectors$';\nimport { EntityCollectionServiceFactory } from './entity-collection-service-factory';\n\n/** Core ingredients of an EntityServices class */\n@Injectable()\nexport class EntityServicesElements {\n  constructor(\n    /**\n     * Creates EntityCollectionService instances for\n     * a cached collection of T entities in the ngrx store.\n     */\n    public readonly entityCollectionServiceFactory: EntityCollectionServiceFactory,\n    /** Creates EntityDispatchers for entity collections */\n    entityDispatcherFactory: EntityDispatcherFactory,\n    /** Creates observable EntitySelectors$ for entity collections. */\n    entitySelectors$Factory: EntitySelectors$Factory,\n    /** The ngrx store, scoped to the EntityCache */\n    public readonly store: Store<EntityCache>\n  ) {\n    this.entityActionErrors$ = entitySelectors$Factory.entityActionErrors$;\n    this.entityCache$ = entitySelectors$Factory.entityCache$;\n    this.reducedActions$ = entityDispatcherFactory.reducedActions$;\n  }\n\n  /** Observable of error EntityActions (e.g. QUERY_ALL_ERROR) for all entity types */\n  readonly entityActionErrors$: Observable<EntityAction>;\n\n  /** Observable of the entire entity cache */\n  readonly entityCache$: Observable<EntityCache> | Store<EntityCache>;\n\n  /**\n   * Actions scanned by the store after it processed them with reducers.\n   * A replay observable of the most recent action reduced by the store.\n   */\n  readonly reducedActions$: Observable<Action>;\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { Action, Store } from '@ngrx/store';\n\nimport { Observable } from 'rxjs';\n\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityCollectionService } from './entity-collection-service';\nimport { EntityCollectionServiceBase } from './entity-collection-service-base';\nimport { EntityCollectionServiceFactory } from './entity-collection-service-factory';\nimport { EntityCollectionServiceMap, EntityServices } from './entity-services';\nimport { EntitySelectorsFactory } from '../selectors/entity-selectors';\nimport { EntitySelectors$, EntitySelectors$Factory } from '../selectors/entity-selectors$';\nimport { EntityServicesElements } from './entity-services-elements';\n\n// tslint:disable:member-ordering\n\n/**\n * Base/default class of a central registry of EntityCollectionServices for all entity types.\n * Create your own subclass to add app-specific members for an improved developer experience.\n *\n * @example\n * export class EntityServices extends EntityServicesBase {\n *   constructor(entityServicesElements: EntityServicesElements) {\n *     super(entityServicesElements);\n *   }\n *   // Extend with well-known, app entity collection services\n *   // Convenience property to return a typed custom entity collection service\n *   get companyService() {\n *     return this.getEntityCollectionService<Model.Company>('Company') as CompanyService;\n *   }\n *   // Convenience dispatch methods\n *   clearCompany(companyId: string) {\n *     this.dispatch(new ClearCompanyAction(companyId));\n *   }\n * }\n */\n@Injectable()\nexport class EntityServicesBase implements EntityServices {\n  // Dear ngrx-data developer: think hard before changing the constructor.\n  // Doing so will break apps that derive from this base class,\n  // and many apps will derive from this class.\n  //\n  // Do not give this constructor an implementation.\n  // Doing so makes it hard to mock classes that derive from this class.\n  // Use getter properties instead. For example, see entityCache$\n  constructor(private entityServicesElements: EntityServicesElements) {}\n\n  // #region EntityServicesElement-based properties\n\n  /** Observable of error EntityActions (e.g. QUERY_ALL_ERROR) for all entity types */\n  get entityActionErrors$(): Observable<EntityAction> {\n    return this.entityServicesElements.entityActionErrors$;\n  }\n\n  /** Observable of the entire entity cache */\n  get entityCache$(): Observable<EntityCache> | Store<EntityCache> {\n    return this.entityServicesElements.entityCache$;\n  }\n\n  /** Factory to create a default instance of an EntityCollectionService */\n  get entityCollectionServiceFactory(): EntityCollectionServiceFactory {\n    return this.entityServicesElements.entityCollectionServiceFactory;\n  }\n\n  /**\n   * Actions scanned by the store after it processed them with reducers.\n   * A replay observable of the most recent action reduced by the store.\n   */\n  get reducedActions$(): Observable<Action> {\n    return this.entityServicesElements.reducedActions$;\n  }\n\n  /** The ngrx store, scoped to the EntityCache */\n  protected get store(): Store<EntityCache> {\n    return this.entityServicesElements.store;\n  }\n\n  // #endregion EntityServicesElement-based properties\n\n  /** Dispatch any action to the store */\n  dispatch(action: Action) {\n    this.store.dispatch(action);\n  }\n\n  /** Registry of EntityCollectionService instances */\n  private readonly EntityCollectionServices: EntityCollectionServiceMap = {};\n\n  /**\n   * Create a new default instance of an EntityCollectionService.\n   * Prefer getEntityCollectionService() unless you really want a new default instance.\n   * This one will NOT be registered with EntityServices!\n   * @param entityName {string} Name of the entity type of the service\n   */\n  protected createEntityCollectionService<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(\n    entityName: string\n  ): EntityCollectionService<T> {\n    return this.entityCollectionServiceFactory.create<T, S$>(entityName);\n  }\n\n  /** Get (or create) the singleton instance of an EntityCollectionService\n   * @param entityName {string} Name of the entity type of the service\n   */\n  getEntityCollectionService<T, S$ extends EntitySelectors$<T> = EntitySelectors$<T>>(entityName: string): EntityCollectionService<T> {\n    let service = this.EntityCollectionServices[entityName];\n    if (!service) {\n      service = this.createEntityCollectionService<T, S$>(entityName);\n      this.EntityCollectionServices[entityName] = service;\n    }\n    return service;\n  }\n\n  /** Register an EntityCollectionService under its entity type name.\n   * Will replace a pre-existing service for that type.\n   * @param service {EntityCollectionService} The entity service\n   * @param serviceName {string} optional service name to use instead of the service's entityName\n   */\n  registerEntityCollectionService<T>(service: EntityCollectionService<T>, serviceName?: string) {\n    this.EntityCollectionServices[serviceName || service.entityName] = service;\n  }\n\n  /**\n   * Register entity services for several entity types at once.\n   * Will replace a pre-existing service for that type.\n   * @param entityCollectionServices {EntityCollectionServiceMap | EntityCollectionService<any>[]}\n   * EntityCollectionServices to register, either as a map or an array\n   */\n  registerEntityCollectionServices(entityCollectionServices: EntityCollectionServiceMap | EntityCollectionService<any>[]): void {\n    if (Array.isArray(entityCollectionServices)) {\n      entityCollectionServices.forEach(service => this.registerEntityCollectionService(service));\n    } else {\n      Object.keys(entityCollectionServices || {}).forEach(serviceName => {\n        this.registerEntityCollectionService(entityCollectionServices[serviceName], serviceName);\n      });\n    }\n  }\n}\n","import { Action, Store } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityCache } from '../reducers/entity-cache';\nimport { EntityCollectionService } from './entity-collection-service';\nimport { EntityCollectionServiceFactory } from './entity-collection-service-factory';\n\n// tslint:disable:member-ordering\n\n/**\n * Class-Interface for EntityCache and EntityCollection services.\n * Serves as an Angular provider token for this service class.\n * Includes a registry of EntityCollectionServices for all entity types.\n * Creates a new default EntityCollectionService for any entity type not in the registry.\n * Optionally register specialized EntityCollectionServices for individual types\n */\nexport abstract class EntityServices {\n  /** Dispatch any action to the store */\n  abstract dispatch(action: Action): void;\n\n  /** Observable of error EntityActions (e.g. QUERY_ALL_ERROR) for all entity types */\n  abstract readonly entityActionErrors$: Observable<EntityAction>;\n\n  /** Observable of the entire entity cache */\n  abstract readonly entityCache$: Observable<EntityCache> | Store<EntityCache>;\n\n  /** Get (or create) the singleton instance of an EntityCollectionService\n   * @param entityName {string} Name of the entity type of the service\n   */\n  abstract getEntityCollectionService<T = any>(entityName: string): EntityCollectionService<T>;\n\n  /**\n   * Actions scanned by the store after it processed them with reducers.\n   * A replay observable of the most recent Action (not just EntityAction) reduced by the store.\n   */\n  abstract readonly reducedActions$: Observable<Action>;\n\n  // #region EntityCollectionService creation and registration API\n\n  /** Register an EntityCollectionService under its entity type name.\n   * Will replace a pre-existing service for that type.\n   * @param service {EntityCollectionService} The entity service\n   */\n  abstract registerEntityCollectionService<T>(service: EntityCollectionService<T>): void;\n\n  /** Register entity services for several entity types at once.\n   * Will replace a pre-existing service for that type.\n   * @param entityCollectionServices Array of EntityCollectionServices to register\n   */\n  abstract registerEntityCollectionServices(entityCollectionServices: EntityCollectionService<any>[]): void;\n\n  /** Register entity services for several entity types at once.\n   * Will replace a pre-existing service for that type.\n   * @param entityCollectionServiceMap Map of service-name to entity-collection-service\n   */\n  abstract registerEntityCollectionServices(\n    // tslint:disable-next-line:unified-signatures\n    entityCollectionServiceMap: EntityCollectionServiceMap\n  ): void;\n  // #endregion EntityCollectionService creation and registration API\n}\n\n/**\n * A map of service or entity names to their corresponding EntityCollectionServices.\n */\nexport interface EntityCollectionServiceMap {\n  [entityName: string]: EntityCollectionService<any>;\n}\n","import { EntityState } from '@ngrx/entity';\nimport { Dictionary } from '../utils/ngrx-entity-models';\n\n/** Types of change in a ChangeState instance */\nexport enum ChangeType {\n  /** The entity has not changed from its last known server state. */\n  Unchanged = 0,\n  /** The entity was added to the collection */\n  Added,\n  /** The entity is scheduled for delete and was removed from the collection */\n  Deleted,\n  /** The entity in the collection was updated */\n  Updated\n}\n\n/**\n * Change state for an entity with unsaved changes;\n * an entry in an EntityCollection.changeState map\n */\nexport interface ChangeState<T> {\n  changeType: ChangeType;\n  originalValue?: T | undefined;\n}\n\n/**\n * Map of entity primary keys to entity ChangeStates.\n * Each entry represents an entity with unsaved changes.\n */\nexport type ChangeStateMap<T> = Dictionary<ChangeState<T>>;\n\n/**\n * Data and information about a collection of entities of a single type.\n * EntityCollections are maintained in the EntityCache within the ngrx store.\n */\nexport interface EntityCollection<T = any> extends EntityState<T> {\n  /** Name of the entity type for this collection */\n  entityName: string;\n  /** A map of ChangeStates, keyed by id, for entities with unsaved changes */\n  changeState: ChangeStateMap<T>;\n  /** The user's current collection filter pattern */\n  filter: string;\n  /** true if collection was ever filled by QueryAll; forced false if cleared */\n  loaded: boolean;\n  /** true when a query or save operation is in progress */\n  loading: boolean;\n}\n","import { EntityAdapter, EntityState } from '@ngrx/entity';\n\nimport { ChangeState, ChangeStateMap, ChangeType, EntityCollection } from './entity-collection';\nimport { defaultSelectId } from '../utils/utilities';\nimport { Dictionary, IdSelector, Update } from '../utils/ngrx-entity-models';\nimport { EntityAction, EntityActionOptions } from '../actions/entity-action';\nimport { EntityChangeTracker } from './entity-change-tracker';\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\n/**\n * The default implementation of EntityChangeTracker with\n * methods for tracking, committing, and reverting/undoing unsaved entity changes.\n * Used by EntityCollectionReducerMethods which should call tracker methods BEFORE modifying the collection.\n * See EntityChangeTracker docs.\n */\nexport class EntityChangeTrackerBase<T> implements EntityChangeTracker<T> {\n  constructor(private adapter: EntityAdapter<T>, private selectId: IdSelector<T>) {\n    /** Extract the primary key (id); default to `id` */\n    this.selectId = selectId || defaultSelectId;\n  }\n\n  // #region commit methods\n  /**\n   * Commit all changes as when the collection has been completely reloaded from the server.\n   * Harmless when there are no entity changes to commit.\n   * @param collection The entity collection\n   */\n  commitAll(collection: EntityCollection<T>): EntityCollection<T> {\n    return Object.keys(collection.changeState).length === 0 ? collection : { ...collection, changeState: {} };\n  }\n\n  /**\n   * Commit changes for the given entities as when they have been refreshed from the server.\n   * Harmless when there are no entity changes to commit.\n   * @param entityOrIdList The entities to clear tracking or their ids.\n   * @param collection The entity collection\n   */\n  commitMany(entityOrIdList: (number | string | T)[], collection: EntityCollection<T>): EntityCollection<T> {\n    if (entityOrIdList == null || entityOrIdList.length === 0) {\n      return collection; // nothing to commit\n    }\n    let didMutate = false;\n    const changeState = entityOrIdList.reduce((chgState, entityOrId) => {\n      const id = typeof entityOrId === 'object' ? this.selectId(entityOrId) : entityOrId;\n      if (chgState[id]) {\n        if (!didMutate) {\n          chgState = { ...chgState };\n          didMutate = true;\n        }\n        delete chgState[id];\n      }\n      return chgState;\n    }, collection.changeState);\n\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Commit changes for the given entity as when it have been refreshed from the server.\n   * Harmless when no entity changes to commit.\n   * @param entityOrId The entity to clear tracking or its id.\n   * @param collection The entity collection\n   */\n  commitOne(entityOrId: number | string | T, collection: EntityCollection<T>): EntityCollection<T> {\n    return entityOrId == null ? collection : this.commitMany([entityOrId], collection);\n  }\n\n  // #endregion commit methods\n\n  // #region merge query\n  /**\n   * Merge query results into the collection, adjusting the ChangeState per the mergeStrategy.\n   * @param entities Entities returned from querying the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a queried entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.PreserveChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeQueryResults(entities: T[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    return this.mergeServerUpserts(entities, collection, MergeStrategy.PreserveChanges, mergeStrategy);\n  }\n  // #endregion merge query results\n\n  // #region merge save results\n  /**\n   * Merge result of saving new entities into the collection, adjusting the ChangeState per the mergeStrategy.\n   * The default is MergeStrategy.OverwriteChanges.\n   * @param entities Entities returned from saving new entities to the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a saved entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveAdds(entities: T[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    return this.mergeServerUpserts(entities, collection, MergeStrategy.OverwriteChanges, mergeStrategy);\n  }\n\n  /**\n   * Merge successful result of deleting entities on the server that have the given primary keys\n   * Clears the entity changeState for those keys unless the MergeStrategy is ignoreChanges.\n   * @param entities keys primary keys of the entities to remove/delete.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to adjust change tracking when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveDeletes(keys: (number | string)[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    mergeStrategy = mergeStrategy == null ? MergeStrategy.OverwriteChanges : mergeStrategy;\n    // same logic for all non-ignore merge strategies: always clear (commit) the changes\n    const deleteIds = keys as string[]; // make TypeScript happy\n    collection = mergeStrategy === MergeStrategy.IgnoreChanges ? collection : this.commitMany(deleteIds, collection);\n    return this.adapter.removeMany(deleteIds, collection);\n  }\n\n  /**\n   * Merge result of saving updated entities into the collection, adjusting the ChangeState per the mergeStrategy.\n   * The default is MergeStrategy.OverwriteChanges.\n   * @param updateResponseData Entity response data returned from saving updated entities to the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a saved entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @param [skipUnchanged] True means skip update if server didn't change it. False by default.\n   * If the update was optimistic and the server didn't make more changes of its own\n   * then the updates are already in the collection and shouldn't make them again.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveUpdates(\n    updateResponseData: UpdateResponseData<T>[],\n    collection: EntityCollection<T>,\n    mergeStrategy?: MergeStrategy,\n    skipUnchanged = false\n  ): EntityCollection<T> {\n    if (updateResponseData == null || updateResponseData.length === 0) {\n      return collection; // nothing to merge.\n    }\n\n    let didMutate = false;\n    let changeState = collection.changeState;\n    mergeStrategy = mergeStrategy == null ? MergeStrategy.OverwriteChanges : mergeStrategy;\n    let updates: Update<T>[];\n\n    switch (mergeStrategy) {\n      case MergeStrategy.IgnoreChanges:\n        updates = filterChanged(updateResponseData);\n        return this.adapter.updateMany(updates, collection);\n\n      case MergeStrategy.OverwriteChanges:\n        changeState = updateResponseData.reduce((chgState, update) => {\n          const oldId = update.id;\n          const change = chgState[oldId];\n          if (change) {\n            if (!didMutate) {\n              chgState = { ...chgState };\n              didMutate = true;\n            }\n            delete chgState[oldId];\n          }\n          return chgState;\n        }, collection.changeState);\n\n        collection = didMutate ? { ...collection, changeState } : collection;\n\n        updates = filterChanged(updateResponseData);\n        return this.adapter.updateMany(updates, collection);\n\n      case MergeStrategy.PreserveChanges: {\n        const updateableEntities = [] as UpdateResponseData<T>[];\n        changeState = updateResponseData.reduce((chgState, update) => {\n          const oldId = update.id;\n          const change = chgState[oldId];\n          if (change) {\n            // Tracking a change so update original value but not the current value\n            if (!didMutate) {\n              chgState = { ...chgState };\n              didMutate = true;\n            }\n            const newId = this.selectId(update.changes);\n            const oldChangeState = chgState[oldId];\n            // If the server changed the id, register the new \"originalValue\" under the new id\n            // and remove the change tracked under the old id.\n            if (newId !== oldId) {\n              delete chgState[oldId];\n            }\n            const newOrigValue = { ...(oldChangeState.originalValue as any), ...(update.changes as any) };\n            chgState[newId] = { ...oldChangeState, originalValue: newOrigValue };\n          } else {\n            updateableEntities.push(update);\n          }\n          return chgState;\n        }, collection.changeState);\n        collection = didMutate ? { ...collection, changeState } : collection;\n\n        updates = filterChanged(updateableEntities);\n        return this.adapter.updateMany(updates, collection);\n      }\n    }\n\n    /**\n     * Conditionally keep only those updates that have additional server changes.\n     * (e.g., for optimistic saves because they updates are already in the current collection)\n     * Strip off the `changed` property.\n     * @responseData Entity response data from server.\n     * May be an UpdateResponseData<T>, a subclass of Update<T> with a 'changed' flag.\n     * @returns Update<T> (without the changed flag)\n     */\n    function filterChanged(responseData: UpdateResponseData<T>[]): Update<T>[] {\n      if (skipUnchanged === true) {\n        // keep only those updates that the server changed (knowable if is UpdateResponseData<T>)\n        responseData = responseData.filter(r => r.changed === true);\n      }\n      // Strip unchanged property from responseData, leaving just the pure Update<T>\n      // TODO: Remove? probably not necessary as the Update isn't stored and adapter will ignore `changed`.\n      return responseData.map(r => ({ id: r.id as any, changes: r.changes }));\n    }\n  }\n\n  /**\n   * Merge result of saving upserted entities into the collection, adjusting the ChangeState per the mergeStrategy.\n   * The default is MergeStrategy.OverwriteChanges.\n   * @param entities Entities returned from saving upserts to the server.\n   * @param collection The entity collection\n   * @param [mergeStrategy] How to merge a saved entity when the corresponding entity in the collection has an unsaved change.\n   * Defaults to MergeStrategy.OverwriteChanges.\n   * @returns The merged EntityCollection.\n   */\n  mergeSaveUpserts(entities: T[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    return this.mergeServerUpserts(entities, collection, MergeStrategy.OverwriteChanges, mergeStrategy);\n  }\n  // #endregion merge save results\n\n  // #region query & save helpers\n  /**\n   *\n   * @param entities Entities to merge\n   * @param collection Collection into which entities are merged\n   * @param defaultMergeStrategy How to merge when action's MergeStrategy is unspecified\n   * @param [mergeStrategy] The action's MergeStrategy\n   */\n  private mergeServerUpserts(\n    entities: T[],\n    collection: EntityCollection<T>,\n    defaultMergeStrategy: MergeStrategy,\n    mergeStrategy?: MergeStrategy\n  ): EntityCollection<T> {\n    if (entities == null || entities.length === 0) {\n      return collection; // nothing to merge.\n    }\n\n    let didMutate = false;\n    let changeState = collection.changeState;\n    mergeStrategy = mergeStrategy == null ? defaultMergeStrategy : mergeStrategy;\n\n    switch (mergeStrategy) {\n      case MergeStrategy.IgnoreChanges:\n        return this.adapter.upsertMany(entities, collection);\n\n      case MergeStrategy.OverwriteChanges:\n        collection = this.adapter.upsertMany(entities, collection);\n\n        changeState = entities.reduce((chgState, entity) => {\n          const id = this.selectId(entity);\n          const change = chgState[id];\n          if (change) {\n            if (!didMutate) {\n              chgState = { ...chgState };\n              didMutate = true;\n            }\n            delete chgState[id];\n          }\n          return chgState;\n        }, collection.changeState);\n\n        return didMutate ? { ...collection, changeState } : collection;\n\n      case MergeStrategy.PreserveChanges: {\n        const upsertEntities = [] as T[];\n        changeState = entities.reduce((chgState, entity) => {\n          const id = this.selectId(entity);\n          const change = chgState[id];\n          if (change) {\n            if (!didMutate) {\n              chgState = { ...chgState };\n              didMutate = true;\n            }\n            chgState[id].originalValue = entity;\n          } else {\n            upsertEntities.push(entity);\n          }\n          return chgState;\n        }, collection.changeState);\n\n        collection = this.adapter.upsertMany(upsertEntities, collection);\n        return didMutate ? { ...collection, changeState } : collection;\n      }\n    }\n  }\n  // #endregion query & save helpers\n\n  // #region track methods\n  /**\n   * Track multiple entities before adding them to the collection.\n   * Does NOT add to the collection (the reducer's job).\n   * @param entities The entities to add. They must all have their ids.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackAddMany(entities: T[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    if (mergeStrategy === MergeStrategy.IgnoreChanges || entities == null || entities.length === 0) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const changeState = entities.reduce((chgState, entity) => {\n      const id = this.selectId(entity);\n      if (id == null || id === '') {\n        throw new Error(`${collection.entityName} entity add requires a key to be tracked`);\n      }\n      const trackedChange = chgState[id];\n\n      if (!trackedChange) {\n        if (!didMutate) {\n          didMutate = true;\n          chgState = { ...chgState };\n        }\n        chgState[id] = { changeType: ChangeType.Added };\n      }\n      return chgState;\n    }, collection.changeState);\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before adding it to the collection.\n   * Does NOT add to the collection (the reducer's job).\n   * @param entity The entity to add. It must have an id.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   * If not specified, implementation supplies a default strategy.\n   */\n  trackAddOne(entity: T, collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    return entity == null ? collection : this.trackAddMany([entity], collection, mergeStrategy);\n  }\n\n  /**\n   * Track multiple entities before removing them with the intention of deleting them on the server.\n   * Does NOT remove from the collection (the reducer's job).\n   * @param keys The primary keys of the entities to delete.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackDeleteMany(keys: (number | string)[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    if (mergeStrategy === MergeStrategy.IgnoreChanges || keys == null || keys.length === 0) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const entityMap = collection.entities;\n    const changeState = keys.reduce((chgState, id) => {\n      const originalValue = entityMap[id];\n      if (originalValue) {\n        const trackedChange = chgState[id];\n        if (trackedChange) {\n          if (trackedChange.changeType === ChangeType.Added) {\n            // Special case: stop tracking an added entity that you delete\n            // The caller must also detect this, remove it immediately from the collection\n            // and skip attempt to delete on the server.\n            cloneChgStateOnce();\n            delete chgState[id];\n          } else if (trackedChange.changeType === ChangeType.Updated) {\n            // Special case: switch change type from Updated to Deleted.\n            cloneChgStateOnce();\n            chgState[id].changeType = ChangeType.Deleted;\n          }\n        } else {\n          // Start tracking this entity\n          cloneChgStateOnce();\n          chgState[id] = { changeType: ChangeType.Deleted, originalValue };\n        }\n      }\n      return chgState;\n\n      function cloneChgStateOnce() {\n        if (!didMutate) {\n          didMutate = true;\n          chgState = { ...chgState };\n        }\n      }\n    }, collection.changeState);\n\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before it is removed with the intention of deleting it on the server.\n   * Does NOT remove from the collection (the reducer's job).\n   * @param key The primary key of the entity to delete.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackDeleteOne(key: number | string, collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    return key == null ? collection : this.trackDeleteMany([key], collection, mergeStrategy);\n  }\n\n  /**\n   * Track multiple entities before updating them in the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param updates The entities to update.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpdateMany(updates: Update<T>[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    if (mergeStrategy === MergeStrategy.IgnoreChanges || updates == null || updates.length === 0) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const entityMap = collection.entities;\n    const changeState = updates.reduce((chgState, update) => {\n      const { id, changes: entity } = update;\n      if (id == null || id === '') {\n        throw new Error(`${collection.entityName} entity update requires a key to be tracked`);\n      }\n      const originalValue = entityMap[id];\n      // Only track if it is in the collection. Silently ignore if it is not.\n      // @ngrx/entity adapter would also silently ignore.\n      // Todo: should missing update entity really be reported as an error?\n      if (originalValue) {\n        const trackedChange = chgState[id];\n        if (!trackedChange) {\n          if (!didMutate) {\n            didMutate = true;\n            chgState = { ...chgState };\n          }\n          chgState[id] = { changeType: ChangeType.Updated, originalValue };\n        }\n      }\n      return chgState;\n    }, collection.changeState);\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before updating it in the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param update The entity to update.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpdateOne(update: Update<T>, collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    return update == null ? collection : this.trackUpdateMany([update], collection, mergeStrategy);\n  }\n\n  /**\n   * Track multiple entities before upserting (adding and updating) them to the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param entities The entities to add or update. They must be complete entities with ids.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpsertMany(entities: T[], collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    if (mergeStrategy === MergeStrategy.IgnoreChanges || entities == null || entities.length === 0) {\n      return collection; // nothing to track\n    }\n    let didMutate = false;\n    const entityMap = collection.entities;\n    const changeState = entities.reduce((chgState, entity) => {\n      const id = this.selectId(entity);\n      if (id == null || id === '') {\n        throw new Error(`${collection.entityName} entity upsert requires a key to be tracked`);\n      }\n      const trackedChange = chgState[id];\n\n      if (!trackedChange) {\n        if (!didMutate) {\n          didMutate = true;\n          chgState = { ...chgState };\n        }\n\n        const originalValue = entityMap[id];\n        chgState[id] = originalValue == null ? { changeType: ChangeType.Added } : { changeType: ChangeType.Updated, originalValue };\n      }\n      return chgState;\n    }, collection.changeState);\n    return didMutate ? { ...collection, changeState } : collection;\n  }\n\n  /**\n   * Track an entity before upsert (adding and updating) it to the collection.\n   * Does NOT update the collection (the reducer's job).\n   * @param entities The entity to add or update. It must be a complete entity with its id.\n   * @param collection The entity collection\n   * @param [mergeStrategy] Track by default. Don't track if is MergeStrategy.IgnoreChanges.\n   */\n  trackUpsertOne(entity: T, collection: EntityCollection<T>, mergeStrategy?: MergeStrategy): EntityCollection<T> {\n    return entity == null ? collection : this.trackUpsertMany([entity], collection, mergeStrategy);\n  }\n  // #endregion track methods\n\n  // #region undo methods\n  /**\n   * Revert the unsaved changes for all collection.\n   * Harmless when there are no entity changes to undo.\n   * @param collection The entity collection\n   */\n  undoAll(collection: EntityCollection<T>): EntityCollection<T> {\n    const ids = Object.keys(collection.changeState);\n\n    const { remove, upsert } = ids.reduce(\n      (acc, id) => {\n        const changeState = acc.chgState[id];\n        switch (changeState.changeType) {\n          case ChangeType.Added:\n            acc.remove.push(id);\n            break;\n          case ChangeType.Deleted:\n            const removed = changeState.originalValue;\n            if (removed) {\n              acc.upsert.push(removed);\n            }\n            break;\n          case ChangeType.Updated:\n            acc.upsert.push(changeState.originalValue);\n            break;\n        }\n        return acc;\n      },\n      // entitiesToUndo\n      {\n        remove: [] as (number | string)[],\n        upsert: [] as T[],\n        chgState: collection.changeState\n      }\n    );\n\n    collection = this.adapter.removeMany(remove as string[], collection);\n    collection = this.adapter.upsertMany(upsert, collection);\n\n    return { ...collection, changeState: {} };\n  }\n\n  /**\n   * Revert the unsaved changes for the given entities.\n   * Harmless when there are no entity changes to undo.\n   * @param entityOrIdList The entities to revert or their ids.\n   * @param collection The entity collection\n   */\n  undoMany(entityOrIdList: (number | string | T)[], collection: EntityCollection<T>): EntityCollection<T> {\n    if (entityOrIdList == null || entityOrIdList.length === 0) {\n      return collection; // nothing to undo\n    }\n    let didMutate = false;\n\n    const { changeState, remove, upsert } = entityOrIdList.reduce(\n      (acc, entityOrId) => {\n        let chgState = acc.changeState;\n        const id = typeof entityOrId === 'object' ? this.selectId(entityOrId) : entityOrId;\n        if (chgState[id]) {\n          if (!didMutate) {\n            chgState = { ...chgState };\n            didMutate = true;\n          }\n          const change = chgState[id];\n          delete chgState[id]; // clear tracking of this entity\n\n          switch (change.changeType) {\n            case ChangeType.Added:\n              acc.remove.push(id);\n              break;\n            case ChangeType.Deleted:\n              const removed = change.originalValue;\n              if (removed) {\n                acc.upsert.push(removed);\n              }\n              break;\n            case ChangeType.Updated:\n              acc.upsert.push(change.originalValue);\n              break;\n          }\n        }\n        return acc;\n      },\n      // entitiesToUndo\n      {\n        remove: [] as (number | string)[],\n        upsert: [] as T[],\n        changeState: collection.changeState\n      }\n    );\n\n    collection = this.adapter.removeMany(remove as string[], collection);\n    collection = this.adapter.upsertMany(upsert, collection);\n    return didMutate ? collection : { ...collection, changeState };\n  }\n\n  /**\n   * Revert the unsaved changes for the given entity.\n   * Harmless when there are no entity changes to undo.\n   * @param entityOrId The entity to revert or its id.\n   * @param collection The entity collection\n   */\n  undoOne(entityOrId: number | string | T, collection: EntityCollection<T>): EntityCollection<T> {\n    return entityOrId == null ? collection : this.undoMany([entityOrId], collection);\n  }\n  // #endregion undo methods\n}\n","import { Injectable } from '@angular/core';\n\nimport { Action } from '@ngrx/store';\nimport { EntityAdapter } from '@ngrx/entity';\n\nimport { merge } from 'rxjs/operators';\n\nimport { ChangeStateMap, ChangeType, EntityCollection } from './entity-collection';\nimport { EntityChangeTrackerBase } from './entity-change-tracker-base';\nimport { defaultSelectId, toUpdateFactory } from '../utils/utilities';\nimport { Dictionary, IdSelector, Update } from '../utils/ngrx-entity-models';\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityActionDataServiceError } from '../dataservices/data-service-error';\nimport { EntityActionGuard } from '../actions/entity-action-guard';\nimport { EntityChangeTracker } from './entity-change-tracker';\nimport { EntityDefinition } from '../entity-metadata/entity-definition';\nimport { EntityDefinitionService } from '../entity-metadata/entity-definition.service';\nimport { EntityOp } from '../actions/entity-op';\nimport { MergeStrategy } from '../actions/merge-strategy';\nimport { UpdateResponseData } from '../actions/update-response-data';\n\n/**\n * Map of {EntityOp} to reducer method for the operation.\n * If an operation is missing, caller should return the collection for that reducer.\n */\nexport interface EntityCollectionReducerMethodMap<T> {\n  [method: string]: (collection: EntityCollection<T>, action?: EntityAction) => EntityCollection<T>;\n}\n\n/**\n * Base implementation of reducer methods for an entity collection.\n */\nexport class EntityCollectionReducerMethods<T> {\n  protected adapter: EntityAdapter<T>;\n  protected guard: EntityActionGuard;\n  /** True if this collection tracks unsaved changes */\n  protected isChangeTracking: boolean;\n\n  /** Extract the primary key (id); default to `id` */\n  selectId: IdSelector<T>;\n\n  /**\n   * Convert an entity (or partial entity) into the `Update<T>` object\n   * `id`: the primary key and\n   * `changes`: the entity (or partial entity of changes).\n   */\n  protected toUpdate: (entity: Partial<T>) => Update<T>;\n\n  /**\n   * Dictionary of the {EntityCollectionReducerMethods} for this entity type,\n   * keyed by the {EntityOp}\n   */\n  readonly methods: EntityCollectionReducerMethodMap<T> = {\n    [EntityOp.CANCEL_PERSIST]: this.cancelPersist.bind(this),\n\n    [EntityOp.QUERY_ALL]: this.queryAll.bind(this),\n    [EntityOp.QUERY_ALL_ERROR]: this.queryAllError.bind(this),\n    [EntityOp.QUERY_ALL_SUCCESS]: this.queryAllSuccess.bind(this),\n\n    [EntityOp.QUERY_BY_KEY]: this.queryByKey.bind(this),\n    [EntityOp.QUERY_BY_KEY_ERROR]: this.queryByKeyError.bind(this),\n    [EntityOp.QUERY_BY_KEY_SUCCESS]: this.queryByKeySuccess.bind(this),\n\n    [EntityOp.QUERY_LOAD]: this.queryLoad.bind(this),\n    [EntityOp.QUERY_LOAD_ERROR]: this.queryLoadError.bind(this),\n    [EntityOp.QUERY_LOAD_SUCCESS]: this.queryLoadSuccess.bind(this),\n\n    [EntityOp.QUERY_MANY]: this.queryMany.bind(this),\n    [EntityOp.QUERY_MANY_ERROR]: this.queryManyError.bind(this),\n    [EntityOp.QUERY_MANY_SUCCESS]: this.queryManySuccess.bind(this),\n\n    [EntityOp.SAVE_ADD_MANY]: this.saveAddMany.bind(this),\n    [EntityOp.SAVE_ADD_MANY_ERROR]: this.saveAddManyError.bind(this),\n    [EntityOp.SAVE_ADD_MANY_SUCCESS]: this.saveAddManySuccess.bind(this),\n\n    [EntityOp.SAVE_ADD_ONE]: this.saveAddOne.bind(this),\n    [EntityOp.SAVE_ADD_ONE_ERROR]: this.saveAddOneError.bind(this),\n    [EntityOp.SAVE_ADD_ONE_SUCCESS]: this.saveAddOneSuccess.bind(this),\n\n    [EntityOp.SAVE_DELETE_MANY]: this.saveDeleteMany.bind(this),\n    [EntityOp.SAVE_DELETE_MANY_ERROR]: this.saveDeleteManyError.bind(this),\n    [EntityOp.SAVE_DELETE_MANY_SUCCESS]: this.saveDeleteManySuccess.bind(this),\n\n    [EntityOp.SAVE_DELETE_ONE]: this.saveDeleteOne.bind(this),\n    [EntityOp.SAVE_DELETE_ONE_ERROR]: this.saveDeleteOneError.bind(this),\n    [EntityOp.SAVE_DELETE_ONE_SUCCESS]: this.saveDeleteOneSuccess.bind(this),\n\n    [EntityOp.SAVE_UPDATE_MANY]: this.saveUpdateMany.bind(this),\n    [EntityOp.SAVE_UPDATE_MANY_ERROR]: this.saveUpdateManyError.bind(this),\n    [EntityOp.SAVE_UPDATE_MANY_SUCCESS]: this.saveUpdateManySuccess.bind(this),\n\n    [EntityOp.SAVE_UPDATE_ONE]: this.saveUpdateOne.bind(this),\n    [EntityOp.SAVE_UPDATE_ONE_ERROR]: this.saveUpdateOneError.bind(this),\n    [EntityOp.SAVE_UPDATE_ONE_SUCCESS]: this.saveUpdateOneSuccess.bind(this),\n\n    [EntityOp.SAVE_UPSERT_MANY]: this.saveUpsertMany.bind(this),\n    [EntityOp.SAVE_UPSERT_MANY_ERROR]: this.saveUpsertManyError.bind(this),\n    [EntityOp.SAVE_UPSERT_MANY_SUCCESS]: this.saveUpsertManySuccess.bind(this),\n\n    [EntityOp.SAVE_UPSERT_ONE]: this.saveUpsertOne.bind(this),\n    [EntityOp.SAVE_UPSERT_ONE_ERROR]: this.saveUpsertOneError.bind(this),\n    [EntityOp.SAVE_UPSERT_ONE_SUCCESS]: this.saveUpsertOneSuccess.bind(this),\n\n    // Do nothing on save errors except turn the loading flag off.\n    // See the ChangeTrackerMetaReducers\n    // Or the app could listen for those errors and do something\n\n    /// cache only operations ///\n\n    [EntityOp.ADD_ALL]: this.addAll.bind(this),\n    [EntityOp.ADD_MANY]: this.addMany.bind(this),\n    [EntityOp.ADD_ONE]: this.addOne.bind(this),\n\n    [EntityOp.REMOVE_ALL]: this.removeAll.bind(this),\n    [EntityOp.REMOVE_MANY]: this.removeMany.bind(this),\n    [EntityOp.REMOVE_ONE]: this.removeOne.bind(this),\n\n    [EntityOp.UPDATE_MANY]: this.updateMany.bind(this),\n    [EntityOp.UPDATE_ONE]: this.updateOne.bind(this),\n\n    [EntityOp.UPSERT_MANY]: this.upsertMany.bind(this),\n    [EntityOp.UPSERT_ONE]: this.upsertOne.bind(this),\n\n    [EntityOp.COMMIT_ALL]: this.commitAll.bind(this),\n    [EntityOp.COMMIT_MANY]: this.commitMany.bind(this),\n    [EntityOp.COMMIT_ONE]: this.commitOne.bind(this),\n    [EntityOp.UNDO_ALL]: this.undoAll.bind(this),\n    [EntityOp.UNDO_MANY]: this.undoMany.bind(this),\n    [EntityOp.UNDO_ONE]: this.undoOne.bind(this),\n\n    [EntityOp.SET_CHANGE_STATE]: this.setChangeState.bind(this),\n    [EntityOp.SET_COLLECTION]: this.setCollection.bind(this),\n    [EntityOp.SET_FILTER]: this.setFilter.bind(this),\n    [EntityOp.SET_LOADED]: this.setLoaded.bind(this),\n    [EntityOp.SET_LOADING]: this.setLoading.bind(this)\n  };\n\n  constructor(\n    public entityName: string,\n    public definition: EntityDefinition<T>,\n    /*\n     * Track changes to entities since the last query or save\n     * Can revert some or all of those changes\n     */\n    public entityChangeTracker?: EntityChangeTracker<T>\n  ) {\n    this.adapter = definition.entityAdapter;\n    this.isChangeTracking = definition.noChangeTracking !== true;\n    this.selectId = definition.selectId;\n\n    this.guard = new EntityActionGuard(entityName, this.selectId);\n    this.toUpdate = toUpdateFactory(this.selectId);\n\n    if (!entityChangeTracker) {\n      this.entityChangeTracker = new EntityChangeTrackerBase<T>(this.adapter, this.selectId);\n    }\n  }\n\n  /** Cancel a persistence operation */\n  protected cancelPersist(collection: EntityCollection<T>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  // #region query operations\n\n  protected queryAll(collection: EntityCollection<T>): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryAllError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Merges query results per the MergeStrategy\n   * Sets loading flag to false and loaded flag to true.\n   */\n  protected queryAllSuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    const data = this.extractData(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    return {\n      ...this.entityChangeTracker.mergeQueryResults(data, collection, mergeStrategy),\n      loaded: true,\n      loading: false\n    };\n  }\n\n  protected queryByKey(collection: EntityCollection<T>, action: EntityAction<number | string>): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryByKeyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  protected queryByKeySuccess(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T> {\n    const data = this.extractData(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = data == null ? collection : this.entityChangeTracker.mergeQueryResults([data], collection, mergeStrategy);\n    return this.setLoadingFalse(collection);\n  }\n\n  protected queryLoad(collection: EntityCollection<T>): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryLoadError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Replaces all entities in the collection\n   * Sets loaded flag to true, loading flag to false,\n   * and clears changeState for the entire collection.\n   */\n  protected queryLoadSuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    const data = this.extractData(action);\n    return {\n      ...this.adapter.addAll(data, collection),\n      loading: false,\n      loaded: true,\n      changeState: {}\n    };\n  }\n\n  protected queryMany(collection: EntityCollection<T>, action: EntityAction): EntityCollection<T> {\n    return this.setLoadingTrue(collection);\n  }\n\n  protected queryManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  protected queryManySuccess(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    const data = this.extractData(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    return {\n      ...this.entityChangeTracker.mergeQueryResults(data, collection, mergeStrategy),\n      loading: false\n    };\n  }\n  // #endregion query operations\n\n  // #region save operations\n\n  // #region saveAddMany\n  /**\n   * Save multiple new entities.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add immediately.\n   * @param collection The collection to which the entities should be added.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an array of entities.\n   * If saving optimistically, the entities must have their keys.\n   */\n  protected saveAddMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entities = this.guard.mustBeEntities<T>(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackAddMany(entities, collection, mergeStrategy);\n      collection = this.adapter.addMany(entities, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save new entities failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, new entities are not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entities are in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveAddManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveAddMany\n\n  // #region saveAddOne\n  /**\n   * Successfully saved new entities to the server.\n   * If saved pessimistically, add the entities from the server to the collection.\n   * If saved optimistically, the added entities are already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field),\n   * and may even return additional new entities.\n   * Therefore, upsert the entities in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   * Note: saveAddManySuccess differs from saveAddOneSuccess when optimistic.\n   * saveAddOneSuccess updates (not upserts) with the lone entity from the server.\n   * There is no effect if the entity is not already in cache.\n   * saveAddManySuccess will add an entity if it is not found in cache.\n   */\n  protected saveAddManySuccess(collection: EntityCollection<T>, action: EntityAction<T[]>) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entities = this.guard.mustBeEntities<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    if (this.isOptimistic(action)) {\n      collection = this.entityChangeTracker.mergeSaveUpserts(entities, collection, mergeStrategy);\n    } else {\n      collection = this.entityChangeTracker.mergeSaveAdds(entities, collection, mergeStrategy);\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveAddMany\n\n  // #region saveAddOne\n  /**\n   * Save a new entity.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add entity immediately.\n   * @param collection The collection to which the entity should be added.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an entity.\n   * If saving optimistically, the entity must have a key.\n   */\n  protected saveAddOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entity = this.guard.mustBeEntity<T>(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackAddOne(entity, collection, mergeStrategy);\n      collection = this.adapter.addOne(entity, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save a new entity failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entity is not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entity is in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveAddOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved a new entity to the server.\n   * If saved pessimistically, add the entity from the server to the collection.\n   * If saved optimistically, the added entity is already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entity in the collection with the returned value (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   */\n  protected saveAddOneSuccess(collection: EntityCollection<T>, action: EntityAction<T>) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entity = this.guard.mustBeEntity<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    if (this.isOptimistic(action)) {\n      const update: UpdateResponseData<T> = this.toUpdate(entity);\n      // Always update the cache with added entity returned from server\n      collection = this.entityChangeTracker.mergeSaveUpdates([update], collection, mergeStrategy, false /*never skip*/);\n    } else {\n      collection = this.entityChangeTracker.mergeSaveAdds([entity], collection, mergeStrategy);\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveAddOne\n\n  // #region saveAddMany\n  // TODO MANY\n  // #endregion saveAddMany\n\n  // #region saveDeleteOne\n  /**\n   * Delete an entity from the server by key and remove it from the collection (if present).\n   * If the entity is an unsaved new entity, remove it from the collection immediately\n   * and skip the server delete request.\n   * An optimistic save removes an existing entity from the collection immediately;\n   * a pessimistic save removes it after the server confirms successful delete.\n   * @param collection Will remove the entity with this key from the collection.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be a primary key or an entity with a key;\n   * this reducer extracts the key from the entity.\n   */\n  protected saveDeleteOne(collection: EntityCollection<T>, action: EntityAction<number | string | T>): EntityCollection<T> {\n    const toDelete = this.extractData(action);\n    const deleteId = typeof toDelete === 'object' ? this.selectId(toDelete) : toDelete;\n    const change = collection.changeState[deleteId];\n    // If entity is already tracked ...\n    if (change) {\n      if (change.changeType === ChangeType.Added) {\n        // Remove the added entity immediately and forget about its changes (via commit).\n        collection = this.adapter.removeOne(deleteId as string, collection);\n        collection = this.entityChangeTracker.commitOne(deleteId, collection);\n        // Should not waste effort trying to delete on the server because it can't be there.\n        action.payload.skip = true;\n      } else {\n        // Re-track it as a delete, even if tracking is turned off for this call.\n        collection = this.entityChangeTracker.trackDeleteOne(deleteId, collection);\n      }\n    }\n\n    // If optimistic delete, track current state and remove immediately.\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackDeleteOne(deleteId, collection, mergeStrategy);\n      collection = this.adapter.removeOne(deleteId as string, collection);\n    }\n\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to delete the entity on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entity could still be in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entity is not in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveDeleteOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully deleted entity on the server. The key of the deleted entity is in the action payload data.\n   * If saved pessimistically, if the entity is still in the collection it will be removed.\n   * If saved optimistically, the entity has already been removed from the collection.\n   */\n  protected saveDeleteOneSuccess(collection: EntityCollection<T>, action: EntityAction<number | string>): EntityCollection<T> {\n    const deleteId = this.extractData(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.mergeSaveDeletes([deleteId], collection, mergeStrategy);\n    } else {\n      // Pessimistic: ignore mergeStrategy. Remove entity from the collection and from change tracking.\n      collection = this.adapter.removeOne(deleteId as string, collection);\n      collection = this.entityChangeTracker.commitOne(deleteId, collection);\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveDeleteOne\n\n  // #region saveDeleteMany\n  /**\n   * Delete multiple entities from the server by key and remove them from the collection (if present).\n   * Removes unsaved new entities from the collection immediately\n   * but the id is still sent to the server for deletion even though the server will not find that entity.\n   * Therefore, the server must be willing to ignore a delete request for an entity it cannot find.\n   * An optimistic save removes existing entities from the collection immediately;\n   * a pessimistic save removes them after the server confirms successful delete.\n   * @param collection Removes entities from this collection.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an array of primary keys or entities with a key;\n   * this reducer extracts the key from the entity.\n   */\n  protected saveDeleteMany(collection: EntityCollection<T>, action: EntityAction<(number | string | T)[]>): EntityCollection<T> {\n    const deleteIds = this.extractData(action).map(d => (typeof d === 'object' ? this.selectId(d) : d));\n    deleteIds.forEach(deleteId => {\n      const change = collection.changeState[deleteId];\n      // If entity is already tracked ...\n      if (change) {\n        if (change.changeType === ChangeType.Added) {\n          // Remove the added entity immediately and forget about its changes (via commit).\n          collection = this.adapter.removeOne(deleteId as string, collection);\n          collection = this.entityChangeTracker.commitOne(deleteId, collection);\n          // Should not waste effort trying to delete on the server because it can't be there.\n          action.payload.skip = true;\n        } else {\n          // Re-track it as a delete, even if tracking is turned off for this call.\n          collection = this.entityChangeTracker.trackDeleteOne(deleteId, collection);\n        }\n      }\n    });\n    // If optimistic delete, track current state and remove immediately.\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackDeleteMany(deleteIds, collection, mergeStrategy);\n      collection = this.adapter.removeMany(deleteIds as string[], collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to delete the entities on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entities could still be in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entities are not in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveDeleteManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully deleted entities on the server. The keys of the deleted entities are in the action payload data.\n   * If saved pessimistically, entities that are still in the collection will be removed.\n   * If saved optimistically, the entities have already been removed from the collection.\n   */\n  protected saveDeleteManySuccess(collection: EntityCollection<T>, action: EntityAction<(number | string)[]>): EntityCollection<T> {\n    const deleteIds = this.extractData(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.mergeSaveDeletes(deleteIds, collection, mergeStrategy);\n    } else {\n      // Pessimistic: ignore mergeStrategy. Remove entity from the collection and from change tracking.\n      collection = this.adapter.removeMany(deleteIds as string[], collection);\n      collection = this.entityChangeTracker.commitMany(deleteIds, collection);\n    }\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveDeleteMany\n\n  // #region saveUpdateOne\n  /**\n   * Save an update to an existing entity.\n   * If saving pessimistically, update the entity in the collection after the server confirms success.\n   * If saving optimistically, update the entity immediately, before the save request.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic,\n   * and the data which, must be an {Update<T>}\n   */\n  protected saveUpdateOne(collection: EntityCollection<T>, action: EntityAction<Update<T>>): EntityCollection<T> {\n    const update = this.guard.mustBeUpdate<T>(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpdateOne(update, collection, mergeStrategy);\n      collection = this.adapter.updateOne(update, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to update the entity on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entity in the collection is in the pre-save state\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entity in the collection was updated\n   * and you may need to compensate for the error.\n   */\n  protected saveUpdateOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved the updated entity to the server.\n   * If saved pessimistically, update the entity in the collection with data from the server.\n   * If saved optimistically, the entity was already updated in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entity in the collection with the returned value (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic update to avoid this risk.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic, and\n   * the update data which, must be an UpdateResponse<T> that corresponds to the Update sent to the server.\n   * You must include an UpdateResponse even if the save was optimistic,\n   * to ensure that the change tracking is properly reset.\n   */\n  protected saveUpdateOneSuccess(collection: EntityCollection<T>, action: EntityAction<UpdateResponseData<T>>): EntityCollection<T> {\n    const update = this.guard.mustBeUpdateResponse<T>(action);\n    const isOptimistic = this.isOptimistic(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.mergeSaveUpdates(\n      [update],\n      collection,\n      mergeStrategy,\n      isOptimistic /*skip unchanged if optimistic */\n    );\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpdateOne\n\n  // #region saveUpdateMany\n  /**\n   * Save updated entities.\n   * If saving pessimistically, update the entities in the collection after the server confirms success.\n   * If saving optimistically, update the entities immediately, before the save request.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic,\n   * and the data which, must be an array of {Update<T>}.\n   */\n  protected saveUpdateMany(collection: EntityCollection<T>, action: EntityAction<Update<T>[]>): EntityCollection<T> {\n    const updates = this.guard.mustBeUpdates<T>(action);\n    if (this.isOptimistic(action)) {\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpdateMany(updates, collection, mergeStrategy);\n      collection = this.adapter.updateMany(updates, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to update entities on the server failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, the entities in the collection are in the pre-save state\n   * you may not have to compensate for the error.\n   * If saved optimistically, the entities in the collection were updated\n   * and you may need to compensate for the error.\n   */\n  protected saveUpdateManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved the updated entities to the server.\n   * If saved pessimistically, the entities in the collection will be updated with data from the server.\n   * If saved optimistically, the entities in the collection were already updated.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entity in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic update to avoid this risk.\n   * @param collection The collection to update\n   * @param action The action payload holds options, including if the save is optimistic,\n   * and the data which, must be an array of UpdateResponse<T>.\n   * You must include an UpdateResponse for every Update sent to the server,\n   * even if the save was optimistic, to ensure that the change tracking is properly reset.\n   */\n  protected saveUpdateManySuccess(collection: EntityCollection<T>, action: EntityAction<UpdateResponseData<T>[]>): EntityCollection<T> {\n    const updates = this.guard.mustBeUpdateResponses<T>(action);\n    const isOptimistic = this.isOptimistic(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.mergeSaveUpdates(updates, collection, mergeStrategy, false /* never skip */);\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpdateMany\n\n  // #region saveUpsertOne\n  /**\n   * Save a new or existing entity.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add immediately.\n   * @param collection The collection to which the entity should be upserted.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be a whole entity.\n   * If saving optimistically, the entity must have its key.\n   */\n  protected saveUpsertOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entity = this.guard.mustBeEntity<T>(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpsertOne(entity, collection, mergeStrategy);\n      collection = this.adapter.upsertOne(entity, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save new or existing entity failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, new or updated entity is not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entities are in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveUpsertOneError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved new or existing entities to the server.\n   * If saved pessimistically, add the entities from the server to the collection.\n   * If saved optimistically, the added entities are already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entities in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   */\n  protected saveUpsertOneSuccess(collection: EntityCollection<T>, action: EntityAction<T>) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entity = this.guard.mustBeEntity<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    // Always update the cache with upserted entities returned from server\n    collection = this.entityChangeTracker.mergeSaveUpserts([entity], collection, mergeStrategy);\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpsertOne\n\n  // #region saveUpsertMany\n  /**\n   * Save multiple new or existing entities.\n   * If saving pessimistically, delay adding to collection until server acknowledges success.\n   * If saving optimistically; add immediately.\n   * @param collection The collection to which the entities should be upserted.\n   * @param action The action payload holds options, including whether the save is optimistic,\n   * and the data, which must be an array of whole entities.\n   * If saving optimistically, the entities must have their keys.\n   */\n  protected saveUpsertMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    if (this.isOptimistic(action)) {\n      const entities = this.guard.mustBeEntities<T>(action); // ensure the entity has a PK\n      const mergeStrategy = this.extractMergeStrategy(action);\n      collection = this.entityChangeTracker.trackUpsertMany(entities, collection, mergeStrategy);\n      collection = this.adapter.upsertMany(entities, collection);\n    }\n    return this.setLoadingTrue(collection);\n  }\n\n  /**\n   * Attempt to save new or existing entities failed or timed-out.\n   * Action holds the error.\n   * If saved pessimistically, new entities are not in the collection and\n   * you may not have to compensate for the error.\n   * If saved optimistically, the unsaved entities are in the collection and\n   * you may need to compensate for the error.\n   */\n  protected saveUpsertManyError(collection: EntityCollection<T>, action: EntityAction<EntityActionDataServiceError>): EntityCollection<T> {\n    return this.setLoadingFalse(collection);\n  }\n\n  /**\n   * Successfully saved new or existing entities to the server.\n   * If saved pessimistically, add the entities from the server to the collection.\n   * If saved optimistically, the added entities are already in the collection.\n   * However, the server might have set or modified other fields (e.g, concurrency field)\n   * Therefore, update the entities in the collection with the returned values (if any)\n   * Caution: in a race, this update could overwrite unsaved user changes.\n   * Use pessimistic add to avoid this risk.\n   */\n  protected saveUpsertManySuccess(collection: EntityCollection<T>, action: EntityAction<T[]>) {\n    // For pessimistic save, ensure the server generated the primary key if the client didn't send one.\n    const entities = this.guard.mustBeEntities<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    // Always update the cache with upserted entities returned from server\n    collection = this.entityChangeTracker.mergeSaveUpserts(entities, collection, mergeStrategy);\n    return this.setLoadingFalse(collection);\n  }\n  // #endregion saveUpsertMany\n\n  // #endregion save operations\n\n  // #region cache-only operations\n\n  /**\n   * Replaces all entities in the collection\n   * Sets loaded flag to true.\n   * Merges query results, preserving unsaved changes\n   */\n  protected addAll(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    const entities = this.guard.mustBeEntities<T>(action);\n    return {\n      ...this.adapter.addAll(entities, collection),\n      loading: false,\n      loaded: true,\n      changeState: {}\n    };\n  }\n\n  protected addMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    const entities = this.guard.mustBeEntities<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackAddMany(entities, collection, mergeStrategy);\n    return this.adapter.addMany(entities, collection);\n  }\n\n  protected addOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T> {\n    const entity = this.guard.mustBeEntity<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackAddOne(entity, collection, mergeStrategy);\n    return this.adapter.addOne(entity, collection);\n  }\n\n  protected removeMany(collection: EntityCollection<T>, action: EntityAction<number[] | string[]>): EntityCollection<T> {\n    // payload must be entity keys\n    const keys = this.guard.mustBeKeys(action) as string[];\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackDeleteMany(keys, collection, mergeStrategy);\n    return this.adapter.removeMany(keys, collection);\n  }\n\n  protected removeOne(collection: EntityCollection<T>, action: EntityAction<number | string>): EntityCollection<T> {\n    // payload must be entity key\n    const key = this.guard.mustBeKey(action) as string;\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackDeleteOne(key, collection, mergeStrategy);\n    return this.adapter.removeOne(key, collection);\n  }\n\n  protected removeAll(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T> {\n    return {\n      ...this.adapter.removeAll(collection),\n      loaded: false, // Only REMOVE_ALL sets loaded to false\n      loading: false,\n      changeState: {} // Assume clearing the collection and not trying to delete all entities\n    };\n  }\n\n  protected updateMany(collection: EntityCollection<T>, action: EntityAction<Update<T>[]>): EntityCollection<T> {\n    // payload must be an array of `Updates<T>`, not entities\n    const updates = this.guard.mustBeUpdates<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpdateMany(updates, collection, mergeStrategy);\n    return this.adapter.updateMany(updates, collection);\n  }\n\n  protected updateOne(collection: EntityCollection<T>, action: EntityAction<Update<T>>): EntityCollection<T> {\n    // payload must be an `Update<T>`, not an entity\n    const update = this.guard.mustBeUpdate<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpdateOne(update, collection, mergeStrategy);\n    return this.adapter.updateOne(update, collection);\n  }\n\n  protected upsertMany(collection: EntityCollection<T>, action: EntityAction<T[]>): EntityCollection<T> {\n    // <v6: payload must be an array of `Updates<T>`, not entities\n    // v6+: payload must be an array of T\n    const entities = this.guard.mustBeEntities<T>(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpsertMany(entities, collection, mergeStrategy);\n    return this.adapter.upsertMany(entities, collection);\n  }\n\n  protected upsertOne(collection: EntityCollection<T>, action: EntityAction<T>): EntityCollection<T> {\n    // <v6: payload must be an `Update<T>`, not an entity\n    // v6+: payload must be a T\n    const entity = this.guard.mustBeEntity(action);\n    const mergeStrategy = this.extractMergeStrategy(action);\n    collection = this.entityChangeTracker.trackUpsertOne(entity, collection, mergeStrategy);\n    return this.adapter.upsertOne(entity, collection);\n  }\n\n  protected commitAll(collection: EntityCollection<T>) {\n    return this.entityChangeTracker.commitAll(collection);\n  }\n\n  protected commitMany(collection: EntityCollection<T>, action: EntityAction<T[]>) {\n    return this.entityChangeTracker.commitMany(this.extractData(action), collection);\n  }\n\n  protected commitOne(collection: EntityCollection<T>, action: EntityAction<T>) {\n    return this.entityChangeTracker.commitOne(this.extractData(action), collection);\n  }\n\n  protected undoAll(collection: EntityCollection<T>) {\n    return this.entityChangeTracker.undoAll(collection);\n  }\n\n  protected undoMany(collection: EntityCollection<T>, action: EntityAction<T[]>) {\n    return this.entityChangeTracker.undoMany(this.extractData(action), collection);\n  }\n\n  protected undoOne(collection: EntityCollection<T>, action: EntityAction<T>) {\n    return this.entityChangeTracker.undoOne(this.extractData(action), collection);\n  }\n\n  /** Dangerous: Completely replace the collection's ChangeState. Use rarely and wisely. */\n  protected setChangeState(collection: EntityCollection<T>, action: EntityAction<ChangeStateMap<T>>) {\n    const changeState = this.extractData(action);\n    return collection.changeState === changeState ? collection : { ...collection, changeState };\n  }\n\n  /**\n   * Dangerous: Completely replace the collection.\n   * Primarily for testing and rehydration from local storage.\n   * Use rarely and wisely.\n   */\n  protected setCollection(collection: EntityCollection<T>, action: EntityAction<EntityCollection<T>>) {\n    const newCollection = this.extractData(action);\n    return collection === newCollection ? collection : newCollection;\n  }\n\n  protected setFilter(collection: EntityCollection<T>, action: EntityAction<any>): EntityCollection<T> {\n    const filter = this.extractData(action);\n    return collection.filter === filter ? collection : { ...collection, filter };\n  }\n\n  protected setLoaded(collection: EntityCollection<T>, action: EntityAction<boolean>): EntityCollection<T> {\n    const loaded = this.extractData(action) === true || false;\n    return collection.loaded === loaded ? collection : { ...collection, loaded };\n  }\n\n  protected setLoading(collection: EntityCollection<T>, action: EntityAction<boolean>): EntityCollection<T> {\n    return this.setLoadingFlag(collection, this.extractData(action));\n  }\n\n  protected setLoadingFalse(collection: EntityCollection<T>): EntityCollection<T> {\n    return this.setLoadingFlag(collection, false);\n  }\n\n  protected setLoadingTrue(collection: EntityCollection<T>): EntityCollection<T> {\n    return this.setLoadingFlag(collection, true);\n  }\n\n  /** Set the collection's loading flag */\n  protected setLoadingFlag(collection: EntityCollection<T>, loading: boolean) {\n    loading = loading === true ? true : false;\n    return collection.loading === loading ? collection : { ...collection, loading };\n  }\n  // #endregion Cache-only operations\n\n  // #region helpers\n  /** Safely extract data from the EntityAction payload */\n  protected extractData<D = any>(action: EntityAction<D>): D {\n    return action.payload && action.payload.data;\n  }\n\n  /** Safely extract MergeStrategy from EntityAction. Set to IgnoreChanges if collection itself is not tracked. */\n  protected extractMergeStrategy(action: EntityAction) {\n    // If not tracking this collection, always ignore changes\n    return this.isChangeTracking ? action.payload && action.payload.mergeStrategy : MergeStrategy.IgnoreChanges;\n  }\n\n  protected isOptimistic(action: EntityAction) {\n    return action.payload && action.payload.isOptimistic === true;\n  }\n\n  // #endregion helpers\n}\n\n/**\n * Creates {EntityCollectionReducerMethods} for a given entity type.\n */\n@Injectable()\nexport class EntityCollectionReducerMethodsFactory {\n  constructor(private entityDefinitionService: EntityDefinitionService) {}\n\n  /** Create the  {EntityCollectionReducerMethods} for the named entity type */\n  create<T>(entityName: string): EntityCollectionReducerMethodMap<T> {\n    const definition = this.entityDefinitionService.getDefinition<T>(entityName);\n    const methodsClass = new EntityCollectionReducerMethods(entityName, definition);\n\n    return methodsClass.methods;\n  }\n}\n","import { Injectable } from '@angular/core';\n\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityCollection } from './entity-collection';\nimport { EntityCollectionReducerMethodsFactory } from './entity-collection-reducer-methods';\n\nexport type EntityCollectionReducer<T = any> = (collection: EntityCollection<T>, action: EntityAction) => EntityCollection<T>;\n\n/** Create a default reducer for a specific entity collection */\n@Injectable()\nexport class EntityCollectionReducerFactory {\n  constructor(private methodsFactory: EntityCollectionReducerMethodsFactory) {}\n\n  /** Create a default reducer for a collection of entities of T */\n  create<T = any>(entityName: string): EntityCollectionReducer<T> {\n    const methods = this.methodsFactory.create<T>(entityName);\n\n    /** Perform Actions against a particular entity collection in the EntityCache */\n    return function entityCollectionReducer(collection: EntityCollection<T>, action: EntityAction): EntityCollection<T> {\n      const reducerMethod = methods[action.payload.entityOp];\n      return reducerMethod ? reducerMethod(collection, action) : collection;\n    };\n  }\n}\n","import { Inject, Injectable, Optional } from '@angular/core';\nimport { ActionReducer, compose, MetaReducer } from '@ngrx/store';\n\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityCollection } from './entity-collection';\nimport { ENTITY_COLLECTION_META_REDUCERS } from './constants';\nimport { EntityCollectionReducer, EntityCollectionReducerFactory } from './entity-collection-reducer';\n\n/** A hash of EntityCollectionReducers */\nexport interface EntityCollectionReducers {\n  [entity: string]: EntityCollectionReducer<any>;\n}\n\n/**\n * Registry of entity types and their previously-constructed reducers.\n * Can create a new CollectionReducer, which it registers for subsequent use.\n */\n@Injectable()\nexport class EntityCollectionReducerRegistry {\n  protected entityCollectionReducers: EntityCollectionReducers = {};\n  private entityCollectionMetaReducer: MetaReducer<EntityCollection, EntityAction>;\n\n  constructor(\n    private entityCollectionReducerFactory: EntityCollectionReducerFactory,\n    @Optional()\n    @Inject(ENTITY_COLLECTION_META_REDUCERS)\n    entityCollectionMetaReducers?: MetaReducer<EntityCollection, EntityAction>[]\n  ) {\n    this.entityCollectionMetaReducer = compose.apply(null, entityCollectionMetaReducers || []);\n  }\n\n  /**\n   * Get the registered EntityCollectionReducer<T> for this entity type or create one and register it.\n   * @param entityName Name of the entity type for this reducer\n   */\n  getOrCreateReducer<T>(entityName: string): EntityCollectionReducer<T> {\n    let reducer: EntityCollectionReducer<T> = this.entityCollectionReducers[entityName];\n\n    if (!reducer) {\n      reducer = this.entityCollectionReducerFactory.create<T>(entityName);\n      reducer = this.registerReducer<T>(entityName, reducer);\n      this.entityCollectionReducers[entityName] = reducer;\n    }\n    return reducer;\n  }\n\n  /**\n   * Register an EntityCollectionReducer for an entity type\n   * @param entityName - the name of the entity type\n   * @param reducer - reducer for that entity type\n   *\n   * Examples:\n   *   registerReducer('Hero', myHeroReducer);\n   *   registerReducer('Villain', myVillainReducer);\n   */\n  registerReducer<T>(entityName: string, reducer: EntityCollectionReducer<T>): ActionReducer<EntityCollection<T>, EntityAction<T>> {\n    reducer = this.entityCollectionMetaReducer(reducer);\n    return (this.entityCollectionReducers[entityName.trim()] = reducer);\n  }\n\n  /**\n   * Register a batch of EntityCollectionReducers.\n   * @param reducers - reducers to merge into existing reducers\n   *\n   * Examples:\n   *   registerReducers({\n   *     Hero: myHeroReducer,\n   *     Villain: myVillainReducer\n   *   });\n   */\n  registerReducers(reducers: EntityCollectionReducers) {\n    const keys = reducers ? Object.keys(reducers) : [];\n    keys.forEach(key => this.registerReducer(key, reducers[key]));\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Action, ActionReducer } from '@ngrx/store';\n\nimport { EntityAction } from '../actions/entity-action';\nimport { EntityActionDataServiceError } from '../dataservices/data-service-error';\nimport { EntityCache } from './entity-cache';\n\nimport {\n  EntityCacheAction,\n  ClearCollections,\n  LoadCollections,\n  MergeQuerySet,\n  SaveEntities,\n  SaveEntitiesCancel,\n  SaveEntitiesError,\n  SaveEntitiesSuccess\n} from '../actions/entity-cache-action';\n\nimport { ChangeSetOperation, ChangeSetItem } from '../actions/entity-cache-change-set';\n\nimport { EntityCollection } from './entity-collection';\nimport { EntityCollectionCreator } from './entity-collection-creator';\nimport { EntityCollectionReducerRegistry } from './entity-collection-reducer-registry';\nimport { EntityOp } from '../actions/entity-op';\nimport { Logger } from '../utils/interfaces';\nimport { MergeStrategy } from '../actions/merge-strategy';\n\n/**\n * Creates the EntityCacheReducer via its create() method\n */\n@Injectable()\nexport class EntityCacheReducerFactory {\n  constructor(\n    private entityCollectionCreator: EntityCollectionCreator,\n    private entityCollectionReducerRegistry: EntityCollectionReducerRegistry,\n    private logger: Logger\n  ) {}\n\n  /**\n   * Create the ngrx-data entity cache reducer which either responds to entity cache level actions\n   * or (more commonly) delegates to an EntityCollectionReducer based on the action.payload.entityName.\n   */\n  create(): ActionReducer<EntityCache, Action> {\n    // This technique ensures a named function appears in the debugger\n    return entityCacheReducer.bind(this);\n\n    function entityCacheReducer(\n      this: EntityCacheReducerFactory,\n      entityCache: EntityCache = {},\n      action: { type: string; payload?: any }\n    ): EntityCache {\n      // EntityCache actions\n      switch (action.type) {\n        case EntityCacheAction.CLEAR_COLLECTIONS: {\n          return this.clearCollectionsReducer(entityCache, action as ClearCollections);\n        }\n\n        case EntityCacheAction.LOAD_COLLECTIONS: {\n          return this.loadCollectionsReducer(entityCache, action as LoadCollections);\n        }\n\n        case EntityCacheAction.MERGE_QUERY_SET: {\n          return this.mergeQuerySetReducer(entityCache, action as MergeQuerySet);\n        }\n\n        case EntityCacheAction.SAVE_ENTITIES: {\n          return this.saveEntitiesReducer(entityCache, action as SaveEntities);\n        }\n\n        case EntityCacheAction.SAVE_ENTITIES_CANCEL: {\n          return this.saveEntitiesCancelReducer(entityCache, action as SaveEntitiesCancel);\n        }\n\n        case EntityCacheAction.SAVE_ENTITIES_ERROR: {\n          return this.saveEntitiesErrorReducer(entityCache, action as SaveEntitiesError);\n        }\n\n        case EntityCacheAction.SAVE_ENTITIES_SUCCESS: {\n          return this.saveEntitiesSuccessReducer(entityCache, action as SaveEntitiesSuccess);\n        }\n\n        case EntityCacheAction.SET_ENTITY_CACHE: {\n          // Completely replace the EntityCache. Be careful!\n          return action.payload.cache;\n        }\n      }\n\n      // Apply entity collection reducer if this is a valid EntityAction for a collection\n      const payload = action.payload;\n      if (payload && payload.entityName && payload.entityOp && !payload.error) {\n        return this.applyCollectionReducer(entityCache, action as EntityAction);\n      }\n\n      // Not a valid EntityAction\n      return entityCache;\n    }\n  }\n\n  /**\n   * Reducer to clear multiple collections at the same time.\n   * @param entityCache the entity cache\n   * @param action a ClearCollections action whose payload is an array of collection names.\n   * If empty array, does nothing. If no array, clears all the collections.\n   */\n  protected clearCollectionsReducer(entityCache: EntityCache, action: ClearCollections) {\n    // tslint:disable-next-line:prefer-const\n    let { collections, tag } = action.payload;\n    const entityOp = EntityOp.REMOVE_ALL;\n\n    if (!collections) {\n      // Collections is not defined. Clear all collections.\n      collections = Object.keys(entityCache);\n    }\n\n    entityCache = collections.reduce((newCache, entityName) => {\n      const payload = { entityName, entityOp };\n      const act: EntityAction = { type: `[${entityName}] ${action.type}`, payload };\n      newCache = this.applyCollectionReducer(newCache, act);\n      return newCache;\n    }, entityCache);\n    return entityCache;\n  }\n\n  /**\n   * Reducer to load collection in the form of a hash of entity data for multiple collections.\n   * @param entityCache the entity cache\n   * @param action a LoadCollections action whose payload is the QuerySet of entity collections to load\n   */\n  protected loadCollectionsReducer(entityCache: EntityCache, action: LoadCollections) {\n    const { collections, tag } = action.payload;\n    const entityOp = EntityOp.ADD_ALL;\n    const entityNames = Object.keys(collections);\n    entityCache = entityNames.reduce((newCache, entityName) => {\n      const payload = {\n        entityName,\n        entityOp,\n        data: collections[entityName]\n      };\n      const act: EntityAction = { type: `[${entityName}] ${action.type}`, payload };\n      newCache = this.applyCollectionReducer(newCache, act);\n      return newCache;\n    }, entityCache);\n    return entityCache;\n  }\n\n  /**\n   * Reducer to merge query sets in the form of a hash of entity data for multiple collections.\n   * @param entityCache the entity cache\n   * @param action a MergeQuerySet action with the query set and a MergeStrategy\n   */\n  protected mergeQuerySetReducer(entityCache: EntityCache, action: MergeQuerySet) {\n    // tslint:disable-next-line:prefer-const\n    let { mergeStrategy, querySet, tag } = action.payload;\n    mergeStrategy = mergeStrategy === null ? MergeStrategy.PreserveChanges : mergeStrategy;\n    const entityOp = EntityOp.UPSERT_MANY;\n\n    const entityNames = Object.keys(querySet);\n    entityCache = entityNames.reduce((newCache, entityName) => {\n      const payload = {\n        entityName,\n        entityOp,\n        data: querySet[entityName],\n        mergeStrategy\n      };\n      const act: EntityAction = { type: `[${entityName}] ${action.type}`, payload };\n      newCache = this.applyCollectionReducer(newCache, act);\n      return newCache;\n    }, entityCache);\n    return entityCache;\n  }\n\n  // #region saveEntities reducers\n  protected saveEntitiesReducer(entityCache: EntityCache, action: SaveEntities) {\n    const { changeSet, correlationId, isOptimistic, mergeStrategy, tag } = action.payload;\n\n    try {\n      changeSet.changes.forEach(item => {\n        const entityName = item.entityName;\n        const payload = {\n          entityName,\n          entityOp: getEntityOp(item),\n          data: item.entities,\n          correlationId,\n          isOptimistic,\n          mergeStrategy,\n          tag\n        };\n\n        const act: EntityAction = { type: `[${entityName}] ${action.type}`, payload };\n        entityCache = this.applyCollectionReducer(entityCache, act);\n        if (act.payload.error) {\n          throw act.payload.error;\n        }\n      });\n    } catch (error) {\n      action.payload.error = error;\n    }\n\n    return entityCache;\n    function getEntityOp(item: ChangeSetItem) {\n      switch (item.op) {\n        case ChangeSetOperation.Add:\n          return EntityOp.SAVE_ADD_MANY;\n        case ChangeSetOperation.Delete:\n          return EntityOp.SAVE_DELETE_MANY;\n        case ChangeSetOperation.Update:\n          return EntityOp.SAVE_UPDATE_MANY;\n        case ChangeSetOperation.Upsert:\n          return EntityOp.SAVE_UPSERT_MANY;\n      }\n    }\n  }\n\n  protected saveEntitiesCancelReducer(entityCache: EntityCache, action: SaveEntitiesCancel) {\n    // This implementation can only clear the loading flag for the collections involved\n    // If the save was optimistic, you'll have to compensate to fix the cache as you think necessary\n    return this.clearLoadingFlags(entityCache, action.payload.entityNames || []);\n  }\n\n  protected saveEntitiesErrorReducer(entityCache: EntityCache, action: SaveEntitiesError) {\n    const originalAction = action.payload.originalAction;\n    const originalChangeSet = originalAction.payload.changeSet;\n\n    // This implementation can only clear the loading flag for the collections involved\n    // If the save was optimistic, you'll have to compensate to fix the cache as you think necessary\n    const entityNames = originalChangeSet.changes.map(item => item.entityName);\n    return this.clearLoadingFlags(entityCache, entityNames);\n  }\n\n  protected saveEntitiesSuccessReducer(entityCache: EntityCache, action: SaveEntitiesSuccess) {\n    const { changeSet, correlationId, isOptimistic, mergeStrategy, tag } = action.payload;\n\n    changeSet.changes.forEach(item => {\n      const entityName = item.entityName;\n      const payload = {\n        entityName,\n        entityOp: getEntityOp(item),\n        data: item.entities,\n        correlationId,\n        isOptimistic,\n        mergeStrategy,\n        tag\n      };\n\n      const act: EntityAction = { type: `[${entityName}] ${action.type}`, payload };\n      entityCache = this.applyCollectionReducer(entityCache, act);\n    });\n\n    return entityCache;\n    function getEntityOp(item: ChangeSetItem) {\n      switch (item.op) {\n        case ChangeSetOperation.Add:\n          return EntityOp.SAVE_ADD_MANY_SUCCESS;\n        case ChangeSetOperation.Delete:\n          return EntityOp.SAVE_DELETE_MANY_SUCCESS;\n        case ChangeSetOperation.Update:\n          return EntityOp.SAVE_UPDATE_MANY_SUCCESS;\n        case ChangeSetOperation.Upsert:\n          return EntityOp.SAVE_UPSERT_MANY_SUCCESS;\n      }\n    }\n  }\n  // #endregion saveEntities reducers\n\n  // #region helpers\n  /** Apply reducer for the action's EntityCollection (if the action targets a collection) */\n  private applyCollectionReducer(cache: EntityCache = {}, action: EntityAction) {\n    const entityName = action.payload.entityName;\n    const collection = cache[entityName];\n    const reducer = this.entityCollectionReducerRegistry.getOrCreateReducer(entityName);\n\n    let newCollection: EntityCollection;\n    try {\n      newCollection = collection ? reducer(collection, action) : reducer(this.entityCollectionCreator.create(entityName), action);\n    } catch (error) {\n      this.logger.error(error);\n      action.payload.error = error;\n    }\n\n    return action.payload.error || collection === newCollection ? cache : { ...cache, [entityName]: newCollection };\n  }\n\n  /** Ensure loading is false for every collection in entityNames */\n  private clearLoadingFlags(entityCache: EntityCache, entityNames: string[]) {\n    let isMutated = false;\n    entityNames.forEach(entityName => {\n      const collection = entityCache[entityName];\n      if (collection.loading) {\n        if (!isMutated) {\n          entityCache = { ...entityCache };\n          isMutated = true;\n        }\n        entityCache[entityName] = { ...collection, loading: false };\n      }\n    });\n    return entityCache;\n  }\n  // #endregion helpers\n}\n","import { Injectable } from '@angular/core';\nimport { Logger } from './interfaces';\n\n@Injectable()\nexport class DefaultLogger implements Logger {\n  error(message?: any, extra?: any) {\n    if (message) {\n      extra ? console.error(message, extra) : console.error(message);\n    }\n  }\n\n  log(message?: any, extra?: any) {\n    if (message) {\n      extra ? console.log(message, extra) : console.log(message);\n    }\n  }\n\n  warn(message?: any, extra?: any) {\n    if (message) {\n      extra ? console.warn(message, extra) : console.warn(message);\n    }\n  }\n}\n","import { Inject, Injectable, Optional } from '@angular/core';\nimport { EntityPluralNames, PLURAL_NAMES_TOKEN } from './interfaces';\n\nconst uncountable = [\n  // 'sheep',\n  // 'fish',\n  // 'deer',\n  // 'moose',\n  // 'rice',\n  // 'species',\n  'equipment',\n  'information',\n  'money',\n  'series'\n];\n\n@Injectable()\nexport class DefaultPluralizer {\n  pluralNames: EntityPluralNames = {};\n\n  constructor(\n    @Optional()\n    @Inject(PLURAL_NAMES_TOKEN)\n    pluralNames: EntityPluralNames[]\n  ) {\n    // merge each plural names object\n    if (pluralNames) {\n      pluralNames.forEach(pn => this.registerPluralNames(pn));\n    }\n  }\n\n  /**\n   * Pluralize a singular name using common English language pluralization rules\n   * Examples: \"company\" -> \"companies\", \"employee\" -> \"employees\", \"tax\" -> \"taxes\"\n   */\n  pluralize(name: string) {\n    const plural = this.pluralNames[name];\n    if (plural) {\n      return plural;\n    }\n    // singular and plural are the same\n    if (uncountable.indexOf(name.toLowerCase()) >= 0) {\n      return name;\n      // vowel + y\n    } else if (/[aeiou]y$/.test(name)) {\n      return name + 's';\n      // consonant + y\n    } else if (name.endsWith('y')) {\n      return name.substr(0, name.length - 1) + 'ies';\n      // endings typically pluralized with 'es'\n    } else if (/[s|ss|sh|ch|x|z]$/.test(name)) {\n      return name + 'es';\n    } else {\n      return name + 's';\n    }\n  }\n\n  /**\n   * Register a mapping of entity type name to the entity name's plural\n   * @param pluralNames {EntityPluralNames} plural names for entity types\n   */\n  registerPluralNames(pluralNames: EntityPluralNames): void {\n    this.pluralNames = { ...this.pluralNames, ...(pluralNames || {}) };\n  }\n}\n","/*\nClient-side id-generators\n\nThese GUID utility functions are not used by ngrx-data itself at this time.\nThey are included as candidates for generating persistable correlation ids if that becomes desirable.\nThey are also safe for generating unique entity ids on the client.\n\nNote they produce 32-character hexadecimal UUID strings,\nnot the 128-bit representation found in server-side languages and databases.\n\nThese utilities are experimental and may be withdrawn or replaced in future.\n*/\n\n/**\n * Creates a Universally Unique Identifier (AKA GUID)\n */\nexport function getUuid() {\n  // The original implementation is based on this SO answer:\n  // http://stackoverflow.com/a/2117523/200253\n  return 'xxxxxxxxxx4xxyxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    // tslint:disable-next-line:no-bitwise\n    const r = (Math.random() * 16) | 0,\n      // tslint:disable-next-line:no-bitwise\n      v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/** Alias for getUuid(). Compare with getGuidComb(). */\nexport function getGuid() {\n  return getUuid();\n}\n\n/**\n * Creates a sortable, pseudo-GUID (globally unique identifier)\n * whose trailing 6 bytes (12 hex digits) are time-based\n * Start either with the given getTime() value, seedTime,\n * or get the current time in ms.\n *\n * @param seed {number} - optional seed for reproducible time-part\n */\nexport function getGuidComb(seed?: number) {\n  // Each new Guid is greater than next if more than 1ms passes\n  // See http://thatextramile.be/blog/2009/05/using-the-guidcomb-identifier-strategy\n  // Based on breeze.core.getUuid which is based on this StackOverflow answer\n  // http://stackoverflow.com/a/2117523/200253\n  //\n  // Convert time value to hex: n.toString(16)\n  // Make sure it is 6 bytes long: ('00'+ ...).slice(-12) ... from the rear\n  // Replace LAST 6 bytes (12 hex digits) of regular Guid (that's where they sort in a Db)\n  //\n  // Play with this in jsFiddle: http://jsfiddle.net/wardbell/qS8aN/\n  const timePart = ('00' + (seed || new Date().getTime()).toString(16)).slice(-12);\n  return (\n    'xxxxxxxxxx4xxyxxx'.replace(/[xy]/g, function(c) {\n      // tslint:disable:no-bitwise\n      const r = (Math.random() * 16) | 0,\n        v = c === 'x' ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    }) + timePart\n  );\n}\n\n// Sort comparison value that's good enough\nexport function guidComparer(l: string, r: string) {\n  const l_low = l.slice(-12);\n  const r_low = r.slice(-12);\n  return l_low !== r_low ? (l_low < r_low ? -1 : +(l_low !== r_low)) : l < r ? -1 : +(l !== r);\n}\n","/////////////////\n// Copied from `@ngrx/entity/models` because that lib doesn't export them\n// They should be exported by @ngrx/entity\n\nexport type ComparerStr<T> = (a: T, b: T) => string;\nexport type ComparerNum<T> = (a: T, b: T) => number;\nexport type Comparer<T> = ComparerNum<T> | ComparerStr<T>;\nexport type IdSelectorStr<T> = (model: Partial<T>) => string;\nexport type IdSelectorNum<T> = (model: Partial<T>) => number;\nexport type IdSelector<T> = IdSelectorStr<T> | IdSelectorNum<T>;\nexport interface DictionaryNum<T> {\n  [id: number]: T;\n}\nexport abstract class Dictionary<T> implements DictionaryNum<T> {\n  [id: string]: T;\n}\n\nexport interface UpdateStr<T> {\n  id: string;\n  changes: Partial<T>;\n}\n\nexport interface UpdateNum<T> {\n  id: number;\n  changes: Partial<T>;\n}\n\n/** Update entity data for an Update action */\nexport type Update<T> = UpdateStr<T> | UpdateNum<T>;\n","import { ModuleWithProviders, NgModule, Inject, Injector, InjectionToken, Optional, OnDestroy } from '@angular/core';\n\nimport { Action, ActionReducer, combineReducers, MetaReducer, ReducerManager, StoreModule } from '@ngrx/store';\n\nimport { CorrelationIdGenerator } from './utils/correlation-id-generator';\nimport { EntityDispatcherDefaultOptions } from './dispatchers/entity-dispatcher-default-options';\nimport { EntityAction } from './actions/entity-action';\nimport { EntityActionFactory } from './actions/entity-action-factory';\nimport { EntityCache } from './reducers/entity-cache';\nimport { EntityCacheDispatcher } from './dispatchers/entity-cache-dispatcher';\nimport { entityCacheSelectorProvider } from './selectors/entity-cache-selector';\nimport { EntityCollectionService } from './entity-services/entity-collection-service';\nimport { EntityCollectionServiceElementsFactory } from './entity-services/entity-collection-service-elements-factory';\nimport { EntityCollectionServiceFactory } from './entity-services/entity-collection-service-factory';\nimport { EntityCollectionServiceMap, EntityServices } from './entity-services/entity-services';\nimport { EntityCollection } from './reducers/entity-collection';\nimport { EntityCollectionCreator } from './reducers/entity-collection-creator';\nimport { EntityCollectionReducerFactory } from './reducers/entity-collection-reducer';\nimport { EntityCollectionReducerMethodsFactory } from './reducers/entity-collection-reducer-methods';\nimport { EntityCollectionReducerRegistry } from './reducers/entity-collection-reducer-registry';\nimport { EntityDispatcherFactory } from './dispatchers/entity-dispatcher-factory';\nimport { EntityDefinitionService } from './entity-metadata/entity-definition.service';\nimport { EntityEffects } from './effects/entity-effects';\nimport { EntityMetadataMap, ENTITY_METADATA_TOKEN } from './entity-metadata/entity-metadata';\n\nimport { EntityCacheReducerFactory } from './reducers/entity-cache-reducer';\nimport {\n  ENTITY_CACHE_NAME,\n  ENTITY_CACHE_NAME_TOKEN,\n  ENTITY_CACHE_META_REDUCERS,\n  ENTITY_COLLECTION_META_REDUCERS,\n  INITIAL_ENTITY_CACHE_STATE\n} from './reducers/constants';\n\nimport { DefaultLogger } from './utils/default-logger';\nimport { DefaultPluralizer } from './utils/default-pluralizer';\nimport { EntitySelectors } from './selectors/entity-selectors';\nimport { EntitySelectorsFactory } from './selectors/entity-selectors';\nimport { EntitySelectors$Factory } from './selectors/entity-selectors$';\nimport { EntityServicesBase } from './entity-services/entity-services-base';\nimport { EntityServicesElements } from './entity-services/entity-services-elements';\nimport { Logger, Pluralizer, PLURAL_NAMES_TOKEN } from './utils/interfaces';\n\nexport interface NgrxDataModuleConfig {\n  entityMetadata?: EntityMetadataMap;\n  entityCacheMetaReducers?: (MetaReducer<EntityCache, Action> | InjectionToken<MetaReducer<EntityCache, Action>>)[];\n  entityCollectionMetaReducers?: MetaReducer<EntityCollection, EntityAction>[];\n  // Initial EntityCache state or a function that returns that state\n  initialEntityCacheState?: EntityCache | (() => EntityCache);\n  pluralNames?: { [name: string]: string };\n}\n\n/**\n * Module without effects or dataservices which means no HTTP calls\n * This module helpful for internal testing.\n * Also helpful for apps that handle server access on their own and\n * therefore opt-out of @ngrx/effects for entities\n */\n@NgModule({\n  imports: [\n    StoreModule // rely on Store feature providers rather than Store.forFeature()\n  ],\n  providers: [\n    CorrelationIdGenerator,\n    EntityDispatcherDefaultOptions,\n    EntityActionFactory,\n    EntityCacheDispatcher,\n    EntityCacheReducerFactory,\n    entityCacheSelectorProvider,\n    EntityCollectionCreator,\n    EntityCollectionReducerFactory,\n    EntityCollectionReducerMethodsFactory,\n    EntityCollectionReducerRegistry,\n    EntityCollectionServiceElementsFactory,\n    EntityCollectionServiceFactory,\n    EntityDefinitionService,\n    EntityDispatcherFactory,\n    EntitySelectorsFactory,\n    EntitySelectors$Factory,\n    EntityServicesElements,\n    { provide: ENTITY_CACHE_NAME_TOKEN, useValue: ENTITY_CACHE_NAME },\n    { provide: EntityServices, useClass: EntityServicesBase },\n    { provide: Logger, useClass: DefaultLogger }\n  ]\n})\nexport class NgrxDataModuleWithoutEffects implements OnDestroy {\n  private entityCacheFeature: any;\n\n  static forRoot(config: NgrxDataModuleConfig): ModuleWithProviders {\n    return {\n      ngModule: NgrxDataModuleWithoutEffects,\n      providers: [\n        {\n          provide: ENTITY_CACHE_META_REDUCERS,\n          useValue: config.entityCacheMetaReducers ? config.entityCacheMetaReducers : []\n        },\n        {\n          provide: ENTITY_COLLECTION_META_REDUCERS,\n          useValue: config.entityCollectionMetaReducers ? config.entityCollectionMetaReducers : []\n        },\n        {\n          provide: PLURAL_NAMES_TOKEN,\n          multi: true,\n          useValue: config.pluralNames ? config.pluralNames : {}\n        }\n      ]\n    };\n  }\n\n  constructor(\n    private reducerManager: ReducerManager,\n    entityCacheReducerFactory: EntityCacheReducerFactory,\n    private injector: Injector,\n    // optional params\n    @Optional()\n    @Inject(ENTITY_CACHE_NAME_TOKEN)\n    private entityCacheName: string,\n    @Optional()\n    @Inject(INITIAL_ENTITY_CACHE_STATE)\n    private initialState: any,\n    @Optional()\n    @Inject(ENTITY_CACHE_META_REDUCERS)\n    private metaReducers: (MetaReducer<EntityCache, Action> | InjectionToken<MetaReducer<EntityCache, Action>>)[]\n  ) {\n    // Add the ngrx-data feature to the Store's features\n    // as Store.forFeature does for StoreFeatureModule\n    const key = entityCacheName || ENTITY_CACHE_NAME;\n\n    initialState = typeof initialState === 'function' ? initialState() : initialState;\n\n    const reducers: MetaReducer<EntityCache, Action>[] = (metaReducers || []).map(mr => {\n      return mr instanceof InjectionToken ? injector.get(mr) : mr;\n    });\n\n    this.entityCacheFeature = {\n      key,\n      reducers: entityCacheReducerFactory.create(),\n      reducerFactory: combineReducers,\n      initialState: initialState || {},\n      metaReducers: reducers\n    };\n    reducerManager.addFeature(this.entityCacheFeature);\n  }\n\n  ngOnDestroy() {\n    this.reducerManager.removeFeature(this.entityCacheFeature);\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { EffectsModule, EffectSources } from '@ngrx/effects';\n\nimport { DefaultDataServiceFactory } from './dataservices/default-data.service';\n\nimport { DefaultPersistenceResultHandler, PersistenceResultHandler } from './dataservices/persistence-result-handler.service';\n\nimport { DefaultHttpUrlGenerator, HttpUrlGenerator } from './dataservices/http-url-generator';\n\nimport { EntityCacheDataService } from './dataservices/entity-cache-data.service';\nimport { EntityCacheEffects } from './effects/entity-cache-effects';\nimport { EntityDataService } from './dataservices/entity-data.service';\nimport { EntityEffects } from './effects/entity-effects';\n\nimport { ENTITY_METADATA_TOKEN } from './entity-metadata/entity-metadata';\n\nimport { ENTITY_CACHE_META_REDUCERS, ENTITY_COLLECTION_META_REDUCERS } from './reducers/constants';\nimport { Pluralizer, PLURAL_NAMES_TOKEN } from './utils/interfaces';\nimport { DefaultPluralizer } from './utils/default-pluralizer';\n\nimport { NgrxDataModuleConfig, NgrxDataModuleWithoutEffects } from './ngrx-data-without-effects.module';\n\n/**\n * Ngrx-data main module includes effects and HTTP data services\n * Configure with `forRoot`.\n * No `forFeature` yet.\n */\n@NgModule({\n  imports: [\n    NgrxDataModuleWithoutEffects,\n    EffectsModule // do not supply effects because can't replace later\n  ],\n  providers: [\n    DefaultDataServiceFactory,\n    EntityCacheDataService,\n    EntityDataService,\n    EntityCacheEffects,\n    EntityEffects,\n    { provide: HttpUrlGenerator, useClass: DefaultHttpUrlGenerator },\n    { provide: PersistenceResultHandler, useClass: DefaultPersistenceResultHandler },\n    { provide: Pluralizer, useClass: DefaultPluralizer }\n  ]\n})\nexport class NgrxDataModule {\n  static forRoot(config: NgrxDataModuleConfig): ModuleWithProviders {\n    return {\n      ngModule: NgrxDataModule,\n      providers: [\n        // TODO: Moved these effects classes up to NgrxDataModule itself\n        // Remove this comment if that was a mistake.\n        // EntityCacheEffects,\n        // EntityEffects,\n        {\n          provide: ENTITY_METADATA_TOKEN,\n          multi: true,\n          useValue: config.entityMetadata ? config.entityMetadata : []\n        },\n        {\n          provide: ENTITY_CACHE_META_REDUCERS,\n          useValue: config.entityCacheMetaReducers ? config.entityCacheMetaReducers : []\n        },\n        {\n          provide: ENTITY_COLLECTION_META_REDUCERS,\n          useValue: config.entityCollectionMetaReducers ? config.entityCollectionMetaReducers : []\n        },\n        {\n          provide: PLURAL_NAMES_TOKEN,\n          multi: true,\n          useValue: config.pluralNames ? config.pluralNames : {}\n        }\n      ]\n    };\n  }\n\n  constructor(private effectSources: EffectSources, entityCacheEffects: EntityCacheEffects, entityEffects: EntityEffects) {\n    // We can't use `forFeature()` because, if we did, the developer could not\n    // replace the ngrx-data `EntityEffects` with a custom alternative.\n    // Replacing that class is an extensibility point we need.\n    //\n    // The FEATURE_EFFECTS token is not exposed, so can't use that technique.\n    // Warning: this alternative approach relies on an undocumented API\n    // to add effect directly rather than through `forFeature()`.\n    // The danger is that EffectsModule.forFeature evolves and we no longer perform a crucial step.\n    this.addEffects(entityCacheEffects);\n    this.addEffects(entityEffects);\n  }\n\n  /**\n   * Add another class instance that contains @Effect methods.\n   * @param effectSourceInstance a class instance that implements effects.\n   * Warning: undocumented @ngrx/effects API\n   */\n  addEffects(effectSourceInstance: any) {\n    this.effectSources.addEffects(effectSourceInstance);\n  }\n}\n","/**\n * Filters the `entities` array argument and returns the original `entities`,\n * or a new filtered array of entities.\n * NEVER mutate the original `entities` array itself.\n **/\nexport type EntityFilterFn<T> = (entities: T[], pattern?: any) => T[];\n\n/**\n * Creates an {EntityFilterFn} that matches RegExp or RegExp string pattern\n * anywhere in any of the given props of an entity.\n * If pattern is a string, spaces are significant and ignores case.\n */\nexport function PropsFilterFnFactory<T = any>(props: (keyof T)[] = []): EntityFilterFn<T> {\n  if (props.length === 0) {\n    // No properties -> nothing could match -> return unfiltered\n    return (entities: T[], pattern: string) => entities;\n  }\n\n  return (entities: T[], pattern: string | RegExp) => {\n    if (!entities) { return []; }\n\n    const regExp = typeof pattern === 'string' ? new RegExp(pattern, 'i') : pattern;\n    if (regExp) {\n      const predicate = (e: any) => props.some(prop => regExp.test(e[prop]));\n      return entities.filter(predicate);\n    }\n    return entities;\n  };\n}\n"]}